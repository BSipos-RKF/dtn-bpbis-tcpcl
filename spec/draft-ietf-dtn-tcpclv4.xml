<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>
<?rfc toc="yes"?>
<rfc ipr="trust200902" category="std" docName="draft-ietf-dtn-tcpclv4-14" obsoletes="7242">
  <front>
    <title abbrev="DTN TCPCLv4">
      Delay-Tolerant Networking TCP Convergence Layer Protocol Version 4
    </title>
    <author initials="B." surname="Sipos" fullname="Brian Sipos">
      <organization abbrev="RKF Engineering">
        RKF Engineering Solutions, LLC
      </organization>
      <address>
        <postal>
          <street>7500 Old Georgetown Road</street>
          <street>Suite 1275</street>
          <city>Bethesda</city>
          <region>MD</region>
          <code>20814-6198</code>
          <country>United States of America</country>
        </postal>
        <email>BSipos@rkf-eng.com</email>
      </address>
    </author>
    <author initials="M." surname="Demmer" fullname="Michael Demmer">
      <organization abbrev="UC Berkeley">
        University of California, Berkeley
      </organization>
      <address>
        <postal>
          <street>Computer Science Division</street>
          <street>445 Soda Hall</street>
          <city>Berkeley</city>
          <region>CA</region>
          <code>94720-1776</code>
          <country>United States of America</country>
        </postal>
        <email>demmer@cs.berkeley.edu</email>
      </address>
    </author>
    <author initials="J." surname="Ott" fullname="Joerg Ott">
      <organization>
        Aalto University
      </organization>
      <address>
        <postal>
          <street>Department of Communications and Networking</street>
          <street>PO Box 13000</street>
          <city>Aalto</city>
          <code>02015</code>
          <country>Finland</country>
        </postal>
        <email>ott@in.tum.de</email>
      </address>
    </author>
    <author initials="S." surname="Perreault" fullname="Simon Perreault">
      <organization>
      </organization>
      <address>
        <postal>
          <street></street>
          <city>Quebec</city>
          <region>QC</region>
          <country>Canada</country>
        </postal>
        <email>simon@per.reau.lt</email>
      </address>
    </author>
    <date year="2019" month="September" day="19" />
    <area>Transport</area>
    <workgroup>Delay Tolerant Networking</workgroup>

    <abstract>
      <t>
        This document describes a revised protocol for the TCP-based convergence
        layer (TCPCL) for Delay-Tolerant Networking (DTN).
        The protocol revision is based on implementation issues in the original
        TCPCL Version 3 of RFC7242 and updates to the Bundle Protocol contents,
        encodings, and convergence layer requirements in Bundle Protocol Version 7.
        Specifically, the TCPCLv4 uses CBOR-encoded BPv7 bundles as its service data
        unit being transported and provides a reliable transport of such bundles.
        Several new IANA registries are defined for TCPCLv4 which define some
        behaviors inherited from TCPCLv3 but with updated encodings and/or semantics.
      </t>
    </abstract>
  </front>
  <middle>
    <section anchor="sec-intro" title="Introduction">
      <t>
        This document describes the TCP-based convergence-layer protocol for
        Delay-Tolerant Networking. Delay-Tolerant Networking is an end-to-
        end architecture providing communications in and/or through highly
        stressed environments, including those with intermittent
        connectivity, long and/or variable delays, and high bit error rates.
        More detailed descriptions of the rationale and capabilities of these
        networks can be found in &quot;Delay-Tolerant Network Architecture&quot;
        <xref target="RFC4838" />.
      </t>
      <t>
        An important goal of the DTN architecture is to accommodate a wide
        range of networking technologies and environments. The protocol used
        for DTN communications is the Bundle Protocol Version 7 (BPv7)
        <xref target="I-D.ietf-dtn-bpbis" />,
        an
        application-layer protocol that is used to construct a store-and-forward
        overlay network.
        BPv7 requires the services of a &quot;convergence-layer adapter&quot; (CLA)
        to send and receive bundles using the service of
        some &quot;native&quot; link, network, or Internet protocol.
        This document describes one such convergence-layer adapter that uses the
        well-known Transmission Control Protocol (TCP).
        This convergence layer is referred to as TCP Convergence Layer Version 4 (TCPCLv4).
        For the remainder of this document, the abbreviation &quot;BP&quot;
        without the version suffix refers to BPv7.
        For the remainder of this document, the abbreviation &quot;TCPCL&quot;
        without the version suffix refers to TCPCLv4.
      </t>
      <t>
        The locations of the TCPCL and the BP in the Internet model protocol
        stack (described in
        <xref target="RFC1122" />) are shown in Figure 1.
        In particular, when BP is using TCP as its bearer with TCPCL as its
        convergence layer, both BP and TCPCL reside at the application layer
        of the Internet model.
      </t>
      <figure anchor="fig-tcpcl-ip-stack"
        title="The Locations of the Bundle Protocol and the TCP Convergence-Layer Protocol above the Internet Protocol Stack">
        <artwork xml:space="preserve">
      +-------------------------+
      |     DTN Application     | -\
      +-------------------------|   |
      |  Bundle Protocol (BP)   |   -&gt; Application Layer
      +-------------------------+   |
      | TCP Conv. Layer (TCPCL) |   |
      +-------------------------+   |
      |     TLS (optional)      | -/
      +-------------------------+
      |          TCP            | ---&gt; Transport Layer
      +-------------------------+
      |       IPv4/IPv6         | ---&gt; Network Layer
      +-------------------------+
      |   Link-Layer Protocol   | ---&gt; Link Layer
      +-------------------------+
</artwork>
      </figure>
      <section title="Scope">
        <t>
          This document describes the format of the protocol data units passed
          between entities participating in TCPCL communications.
          This document does not address:
          <list style="symbols">
            <t>
              The format of protocol data units of the Bundle Protocol, as those
              are defined elsewhere in
              <xref target="I-D.ietf-dtn-bpbis" />.
              This includes the concept of bundle fragmentation or bundle encapsulation.
              The TCPCL transfers bundles as opaque data blocks.
            </t>
            <t>
              Mechanisms for locating or identifying other bundle entities
              (peers) within a network or across an internet.
              The mapping of Node ID to potential CL protocol and network address
              is left to implementation and configuration of the BP Agent
              and its various potential routing strategies.
            </t>
            <t>
              Logic for routing bundles along a path toward a bundle's endpoint.
              This CL protocol is involved only in transporting bundles
              between adjacent nodes in a routing sequence.
            </t>
            <t>
              Policies or mechanisms for assigning X.509 certificates, 
              provisioning or deploying certificates and private keys, 
              or configuring security parameters on an individual BP node or
              across a network.
            </t>
          </list>
          Any TCPCL implementation requires a BP agent to perform those above 
          listed functions in order to perform end-to-end bundle delivery.
        </t>
      </section>
    </section>
    <section title="Requirements Language">
      <t>
      The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, 
      &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, 
      &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;,
      &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as
      described in BCP 14 <xref target="RFC2119" /> <xref target="RFC8174" />
      when, and only when, they appear in all capitals, as shown here.
      </t>
      <section anchor="sec-term-defs" title="Definitions Specific to the TCPCL Protocol">
        <t>
          This section contains definitions specific to the TCPCL protocol.
          <list style="hanging">
            <t hangText="TCPCL Entity:">
              This is the notional TCPCL application that initiates TCPCL sessions.
              This design, implementation, configuration, and specific behavior of such
              an entity is outside of the scope of this document.
              However, the concept of an entity has utility within the scope of 
              this document as the container and initiator of TCPCL sessions.
              The relationship between a TCPCL entity and TCPCL sessions is defined as follows:
              <list>
                <t>
                  A TCPCL Entity MAY actively initiate any number of TCPCL Sessions and should do so 
                  whenever the entity is the initial transmitter of information to another entity in the network.
                </t>
                <t>
                  A TCPCL Entity MAY support zero or more passive listening elements that listen for
                  connection requests from other TCPCL Entities operating on other entitys in the network.
                </t>
                <t>
                  A TCPCL Entity MAY passivley initiate any number of TCPCL Sessions from requests received
                  by its passive listening element(s) if the entity uses such elements.
                </t>
              </list>
              These relationships are illustrated in <xref target="fig-entity-session-relations"/>.
              For most TCPCL behavior within a session, the two entities are 
              symmetric and there is no protocol distinction between them.
              Some specific behavior, particularly during session establishment, distinguishes
              between the active entity and the passive entity.
              For the remainder of this document, the term &quot;entity&quot;
              without the prefix &quot;TCPCL&quot; refers to a TCPCL entity.
            </t>
            <t hangText="TCP Connection:">
              The term Connection in this specification exclusively refers to a TCP connection 
              and any and all behaviors, sessions, and other states association with that TCP connection.
            </t>
            <t hangText="TCPCL Session:">
              A TCPCL session (as opposed to a TCP connection) is a TCPCL 
              communication relationship between two TCPCL entities.
              Within a single TCPCL session there are two possible transfer streams;
              one in each direction, with one stream from each entity being the outbound
              stream and the other being the inbound stream.
              The lifetime of a TCPCL session is bound to the lifetime of an underlying TCP connection.
              A TCPCL session is terminated when the TCP
              connection ends, due either to one or both entities actively
              closing the TCP connection or due to network errors causing
              a failure of the TCP connection.
              For the remainder of this document, the term &quot;session&quot;
              without the prefix &quot;TCPCL&quot; refers to a TCPCL session.
            </t>
            <t hangText="Session parameters:">
              These are a set of
              values used to affect the operation of the TCPCL for a given
              session. The manner in which these parameters are conveyed
              to the bundle entity and thereby to the TCPCL is implementation
              dependent. However, the mechanism by which two entities
              exchange and negotiate the values to be used for a given session
              is described in
              <xref target="sec-contact-negotiate" />.
            </t>
            <t hangText="Transfer Stream:">
              A Transfer stream is a uni-directional user-data path within a TCPCL Session.
              Messages sent over a transfer stream are serialized, meaning that one set of 
              user data must complete its transmission prior to another set of user data 
              being transmitted over the same transfer stream.
              Each uni-directional stream has a single sender entity and a single receiver entity.
            </t>
            <t hangText="Transfer:">
              This refers to the procedures and mechanisms
              for conveyance of an individual bundle from one node to
              another.
              Each transfer within TCPCL is identified by a Transfer ID number
              which is unique only to a single direction within a single Session.
            </t>
            <t hangText="Transfer Segment:">
              A subset of a transfer of user data being communicated over a trasnfer stream.
            </t>
            <t hangText="Idle Session:">
              A TCPCL session is idle while the only messages being transmitted or received
              are KEEPALIVE messages.
            </t>
            <t hangText="Live Session:">
              A TCPCL session is live while any messages are being transmitted or received.
            </t>
            <t hangText="Reason Codes:">
              The TCPCL uses numeric codes to encode specific reasons for individual
              failure/error message types.
            </t>
          </list>
          The relationship between connections, sessions, and streams is shown in <xref target="fig-session-stream"/>.
        </t>
        <figure anchor="fig-entity-session-relations" title="The relationships between TCPCL entities">
          <artwork xml:space="preserve">
+--------------------------------------------+
|                 TCPCL Entity               |
|                                            |      +----------------+
|   +--------------------------------+       |      |                |-+
|   | Actively Inititated Session #1 +-------------&gt;| Other          | |
|   +--------------------------------+       |      | TCPCL Entity's | |
|                  ...                       |      | Passive        | |
|   +--------------------------------+       |      | Listener       | |
|   | Actively Inititated Session #n +-------------&gt;|                | |
|   +--------------------------------+       |      +----------------+ |
|                                            |       +-----------------+
|      +---------------------------+         |
|  +---| +---------------------------+       |      +----------------+
|  |   | | Optional Passive          |       |      |                |-+
|  |   +-| Listener(s)               +&lt;-------------+                | |
|  |     +---------------------------+       |      |                | |
|  |                                         |      | Other          | |
|  |    +---------------------------------+  |      | TCPCL Entity's | |
|  +---&gt;| Passively Inititated Session #1 +--------&gt;| Active         | |
|  |    +---------------------------------+  |      | Initiator(s)   | |
|  |                                         |      |                | |
|  |    +---------------------------------+  |      |                | |
|  +---&gt;| Passively Inititated Session #n +--------&gt;|                | |
|       +---------------------------------+  |      +----------------+ |
|                                            |       +-----------------+
+--------------------------------------------+
</artwork></figure>
        <figure anchor="fig-session-stream" title="The relationship within a TCPCL Session of its two streams">
          <artwork xml:space="preserve">
+----------------------------+              +--------------------------+
|      TCPCL Session         |              |  TCPCL "Other" Session   |
|                            |              |                          |
| +-----------------------+  |              |  +---------------------+ |
| |   TCP Connection      |  |              |  |    TCP Connection   | |
| |                       |  |              |  |                     | |
| | +-------------------+ |  |              |  | +-----------------+ | |
| | | Optional Inbound  | |  |              |  | |  Peer Outbound  | | |
| | | Transfer Stream   |&lt;-[Seg]--[Seg]--[Seg]-| | Transfer Stream | | |
| | |       -----       | |  |              |  | |       -----     | | |
| | |     RECEIVER      | |  |              |  | |      SENDER     | | |
| | +-------------------+ |  |              |  | +-----------------+ | |
| |                       |  |              |  |                     | |
| | +-------------------+ |  |              |  | +-----------------+ | |
| | | Optional Outbound | |  |              |  | |  Peer Inbound   | | |
| | | Transfer Stream   |------[Seg]---[Seg]----&gt;| Transfer Stream | | |
| | |       -----       | |  |              |  | |       -----     | | |
| | |      SENDER       | |  |              |  | |     RECEIVER    | | |
| | +-------------------+ |  |              |  | +-----------------+ | |
| +-----------------------+  |              |  +---------------------+ |
+----------------------------+              +--------------------------+
</artwork></figure>
      </section>
    </section>
    <section anchor="sec-prococol" title="General Protocol Description">
      <t>
        The service of this protocol is the transmission of DTN bundles via
        the Transmission Control Protocol (TCP).
        This document specifies the encapsulation of bundles,
        procedures for TCP setup and teardown, and a set of messages and node
        requirements.
        The general operation of the protocol is as follows.
      </t>
      <section anchor="sec-cl-services" title="Convergence Layer Services">
        <t>
          This version of the TCPCL provides the following services to support
          the overlaying Bundle Protocol agent.
          In all cases, this is not an API defintion but a logical description
          of how the CL can interact with the BP agent.
          Each of these interactions can be associated with any number of 
          additional metadata items as necessary to support the operation
          of the CL or BP agent.
          <list style="hanging">
            <t hangText="Attempt Session:">
              The TCPCL allows a BP agent to pre-emptively attempt to establish
              a TCPCL session with a peer entity.
              Each session attempt can send a different set of session negotiation
              parameters as directed by the BP agent.
            </t>
            <t hangText="Terminate Session:">
              The TCPCL allows a BP agent to pre-emptively terminate an established
              TCPCL session with a peer entity.
              The terminate request is on a per-session basis.
            </t>
            <t hangText="Session State Changed:">
              The TCPCL supports indication when the session state changes.
              The top-level session states indicated are:
              <list>
                <t hangText="Connecting:">A TCP connection is being established. This state only applies to the active entity.</t>
                <t hangText="Contact Negotating:">A TCP connection has been made (as either active or passive entity) and contact negotiation has begun.</t>
                <t hangText="Session Negotiating:">Contact negotation has been completed (including possible TLS use) and session negotiation has begun.</t>
                <t hangText="Established:">The session has been fully established and is ready for its first transfer.</t>
                <t hangText="Ending:">The entity received a SESS_TERM message and is in the ending state.</t>
                <t hangText="Terminated:">The session has finished normal termination sequencing.</t>
                <t hangText="Failed:">The session ended without normal termination sequencing.</t>
              </list>
            </t>
            <t hangText="Session Idle Changed:">
              The TCPCL supports indication when the live/idle sub-state of
              the session changes.
              This occurs only when the top-level session state is 
              &quot;Established&quot;.
              The session transitions from Idle to Live at the at the start
              of a transfer in either transfer stream;
              the session transitions from Live to Idle at the end of a 
              transfer when the other transfer stream does not have an ongoing
              transfer.
              Because TCPCL transmits serially over a TCP connection, it suffers
              from "head of queue blocking" this indication provides
              information about when a session is available for
              immediate transfer start.
            </t>
            <t hangText="Begin Transmission:">
              The principal purpose of the TCPCL is to allow a BP agent to
              transmit bundle data over an established TCPCL session.
              Transmission request is on a per-session basis, the CL does not
              necessarily perform any per-session or inter-session queueing.
              Any queueing of transmissions is the obligation of the BP agent.
            </t>
            <t hangText="Transmission Success:">
              The TCPCL supports positive indication when a bundle has been fully
              transferred to a peer entity.
            </t>
            <t hangText="Transmission Intermediate Progress:">
              The TCPCL supports positive indication of intermediate progress
              of transferr to a peer entity.
              This intermediate progress is at the granularity of each
              transferred segment.
            </t>
            <t hangText="Transmission Failure:">
              The TCPCL supports positive indication of certain reasons for
              bundle transmission failure, notably when the peer entity rejects
              the bundle or when a TCPCL session ends before transferr success.
              The TCPCL itself does not have a notion of transfer timeout.
            </t>
            <t hangText="Reception Initialized:">
              The TCPCL supports indication to the reciver just before any
              transmssion data is sent.
              This corresponds to reception of the XFER_SEGMENT message with
              the START flag of 1.
            </t>
            <t hangText="Interrupt Reception:">
              The TCPCL allows a BP agent to interrupt an individual transfer
              before it has fully completed (successfully or not).
              Interruption can occur any time after the reception is initialized.
            </t>
            <t hangText="Reception Success:">
              The TCPCL supports positive indication when a bundle has been fully
              transferred from a peer entity.
            </t>
            <t hangText="Reception Intermediate Progress:">
              The TCPCL supports positive indication of intermediate progress
              of transfer from the peer entity.
              This intermediate progress is at the granularity of each
              transferred segment.
              Intermediate reception indication allows a BP agent the chance
              to inspect bundle header contents before the entire bundle is
              available, and thus supports the
              &quot;Reception Interruption&quot; capability.
            </t>
            <t hangText="Reception Failure:">
              The TCPCL supports positive indication of certain reasons for
              reception failure, notably when the local entity rejects an attempted
              transfer for some local policy reason or when a TCPCL session
              ends before transfer success.
              The TCPCL itself does not have a notion of transfer timeout.
            </t>
          </list>
        </t>
      </section>
      <section anchor="sec-protocol-session" title="TCPCL Session Overview">
        <t>
          First, one node establishes a TCPCL session to the other by
          initiating a TCP connection in accordance with
          <xref target="RFC0793" />.
          After setup of the TCP connection is
          complete, an initial contact header is exchanged in both directions
          to establish a shared TCPCL version and possibly initiate TLS security.
          Once contact negotiation is complete, TCPCL messaging is available and
          the session negotiation is used to set parameters of the TCPCL session.
          One of these parameters is a Node ID of each TCPCL Entity.
          This is used to assist in routing and forwarding messages by the 
          BP Agent and is part of the authentication capability provided by TLS.
        </t>
        <t>
          Once negotiated, the parameters of a TCPCL session cannot change
          and if there is a desire by either peer to transfer data under 
          different parameters then a new session must be established.
          This makes CL logic simpler but relies on the assumption that
          establishing a TCP connection is lightweight enough that TCP 
          connection overhead is negligable compared to TCPCL data sizes.
        </t>
        <t>
          Once the TCPCL session is established and configured in this way,
          bundles can be transferred in either direction.
          Each transfer is performed by an sequence of 
          logical segments of data within XFER_SEGMENT messages.
          Multiple bundles can be transmitted consecutively in a single 
          direction on a single TCPCL connection.
          Segments from different bundles are never interleaved.
          Bundle interleaving can be
          accomplished by fragmentation at the BP layer or by establishing multiple
          TCPCL sessions between the same peers.
          There is no fundamental limit on the number of TCPCL sessions which
          a single node can establish beyond the limit imposed by the number
          of available (ephemeral) TCP ports of the passive peer.
        </t>
        <t>
          A feature of this protocol is for the receiving node to send
          acknowledgment (XFER_ACK) messages as bundle data segments arrive. The
          rationale behind these acknowledgments is to enable the sender node
          to determine how much of the bundle has been received, so that in
          case the session is interrupted, it can perform reactive
          fragmentation to avoid re-sending the already transmitted part of the
          bundle.
          In addition, there is no explicit flow control on the TCPCL
          layer.
        </t>
        <t>
          A TCPCL receiver can interrupt the
          transmission of a bundle at any point in time by replying with a
          XFER_REFUSE message, which causes the sender to stop transmission
          of the associated bundle (if it hasn't already finished transmission)
          Note: This enables a cross-layer optimization in
          that it allows a receiver that detects that it already has received a
          certain bundle to interrupt transmission as early as possible and
          thus save transmission capacity for other bundles.
        </t>
        <t>
          For sessions that are idle, a KEEPALIVE message is
          sent at a negotiated interval.
          This is used to convey node live-ness information during otherwise
          message-less time intervals.
        </t>
        <t>
          A SESS_TERM message is used to start the ending of a TCPCL session
          (see <xref target="sec-SESS_TERM" />).
          During shutdown sequencing, in-progress transfers can be completed but no
          new transfers can be initiated.
          A SESS_TERM message can also be used to refuse a session setup by a
          peer (see
          <xref target="sec-contact-negotiate" />).
          Regardless of the reason, session termination is initiated by one
          of the entities and responded-to by the other as illustrated by
          <xref target="fig-sessterm-init" /> and 
          <xref target="fig-sessterm-respond" />.
          Even when there are no transfers queued or in-progress, the session
          termination procedure allows each entity to distinguish between
          a clean end to a session and the TCP connection being closed because
          of some underlying network issue.
        </t>
        <t>
          Once a session is established, TCPCL is a symmetric protocol between the peers.
          Both sides can start sending data segments in a session, and one
          side's bundle transfer does not have to complete before the other
          side can start sending data segments on its own. Hence, the protocol
          allows for a bi-directional mode of communication.
          Note that in the case of concurrent bidirectional transmission,
          acknowledgment segments MAY be interleaved with data segments.
        </t>
      </section>
      <section anchor="sec-protocol-states" title="TCPCL States and Transitions">
        <t>
          The states of a nominal TCPCL session (i.e. without session failures)
          are indicated in <xref target="fig-session-states"/>.
        </t>
        <figure anchor="fig-session-states" title="Top-level states of a TCPCL session">
          <artwork xml:space="preserve">
  +-------+
  | START |
  +-------+
      | 
  TCP Establishment
      |
      V
+-----------+            +---------------------+
|    TCP    |-----------&gt;|  Contact / Session  |
| Connected |            |     Negotiation     |
+-----------+            +---------------------+
                                    |
       +-----Session Parameters-----+
       |         Negotiated
       V
+-------------+                     +-------------+
| Established |----New Transfer----&gt;| Established |
|   Session   |                     |   Session   |
|    Idle     |&lt;---Transfers Done---|     Live    |
+-------------+                     +-------------+
      |                                    |
      +------------------------------------+
      |
[SESSTERM] Exchange
      |
      V
+-------------+
| Established |                    +-------------+
|   Session   |----Transfers------&gt;|     TCP     |
|   Ending    |      Done          | Terminating |
+-------------+                    +-------------+
                                           |
     +----------TCP Close Message----------+
     |                                     
     V
 +-------+
 |  END  |
 +-------+
</artwork></figure>
        <t>
          Notes on Established Session states:
          <list>
            <t>Session "Live" means transmitting or reeiving over a transfer stream.</t>
            <t>Session "Idle" means no transmission/reception over a transfer stream.</t>
            <t>Session "Ending" means no new transfers will be allowed.</t>
          </list>
        </t>
        <t>
        Contact negotation involves exchanging a Contact Header (CH) in both
        directions and deriving a negotiated state from the two headers.
        The contact negotiation sequencing is performed either as the
        active or passive peer, and is illustrated in <xref target="fig-contact-init-active"/>
        and <xref target="fig-contact-init-passive"/> respectively which both share the data
        validation and analyze final states of the "[PCH]" activity of
        <xref target="fig-contact-init-process"/> and the "[TCPCLOSE]" activity
        which indicates TCP connection close.
        Successful negotiation results in one of the Session Initiation "[SI]" 
        activities being performed.
        </t>
        <figure anchor="fig-contact-init-active" title="Contact Initiation as Active peer">
          <artwork xml:space="preserve">
+-------+
| START |
+-------+
    |
TCP Connecting
    V
+-----------+
|    TCP    |            +---------+
| Connected |--Send CH--&gt;| Waiting |--Timeout--&gt;[TCPCLOSE]
+-----------+            +---------+
                              |
                          Recevied CH
                              V
                            [PCH]
</artwork></figure>
        <figure anchor="fig-contact-init-passive" title="Contact Initiation as Passive peer">
          <artwork xml:space="preserve">
+-----------+             +---------+
|   TCP     |--Wait for--&gt;| Waiting |--Timeout--&gt;[TCPCLOSE]
| Connected |     CH      +---------+
+-----------+                  |
                          Received CH
                               V
                       +-----------------+
                       | Preparing reply |--Send CH--&gt;[PSI]
                       +-----------------+
</artwork></figure>
        <figure anchor="fig-contact-init-process" title="Processing of Contact Header [PCH]">
          <artwork xml:space="preserve">
+-----------+
|  Peer CH  |
| available |
+-----------+
      |
 Validate and
  Negotiate
      V
 +------------+
 | Negotiated |----Failure---->[TCPCLOSE]
 +------------+                      ^
    |       |                        |
  No TLS    +----Negotiate---+       |
    V               TLS      |    Failure
  +-----------+              V       |
  |   TCPCL   |            +---------------+
  | Messaging |&lt;--Success--| TLS Finished |
  | Available |            +---------------+
  +-----------+
</artwork></figure>
        <t>
        Session negotation involves exchanging a session initialization 
        (SESS_INIT) message in both directions and deriving a negotiated 
        state from the two messages.
        The session negotiation sequencing is performed either as the
        active or passive peer, and is illustrated in <xref target="fig-sess-init-active"/>
        and <xref target="fig-sess-init-passive"/> respectively which both share the data
        validation and analyze final states of <xref target="fig-sess-init-process"/>.
        The validation here includes certificate validation and authentication
        when TLS is used for the session.
        </t>
        <figure anchor="fig-sess-init-active" title="Session Initiation [SI] as Active peer">
          <artwork xml:space="preserve">
+-----------+
|   TCPCL   |                   +---------+
| Messaging |--Send SESS_INIT--&gt;| Waiting |--Timeout--&gt;[SESSTERM]
| Available |                   +---------+
+-----------+                       |
                            Recevied SESS_INIT
                                    |
                                    V
                                  [PSI]
</artwork></figure>
        <figure anchor="fig-sess-init-passive" title="Session Initiation [SI] as Passive peer">
          <artwork xml:space="preserve">
+-----------+
|   TCPCL   |                  +---------+
| Messaging |----Wait for ----&gt;| Waiting |--Timeout--&gt;[SESSTERM]
| Available |    SESS_INIT     +---------+
+-----------+                       |
                            Recevied SESS_INIT
                                    |
                            +-----------------+
                            | Preparing reply |--Send SESS_INIT--&gt;[PSI]
                            +-----------------+
</artwork></figure>
        <figure anchor="fig-sess-init-process" title="Processing of Session Initiation [PSI]">
          <artwork xml:space="preserve">
+----------------+
| Peer SESS_INIT |
|   available    |
+----------------+
        |
   Validate and
    Negotiate
        V
   +------------+
   | Negotiated |---Failure--->[SESSTERM]
   +------------+
        |
     Success
        V
  +--------------+
  | Established  |
  | Session Idle |
  +--------------+
</artwork></figure>
        <t>
        Transfers can occur after a session is established and it's not
        in the ending state.
        Each transfer occurs within a single logical transfer stream
        between a sender and a receiver, as illustrated in
        <xref target="fig-transfer-tx-states"/> and
        <xref target="fig-transfer-rx-states"/> respectively.
        </t>
        <figure anchor="fig-transfer-tx-states" title="Transfer sender states">
          <artwork xml:space="preserve">
                                       +--Send XFER_SEGMENT--+
+--------+                             |                     |
| Stream |                       +-------------+             |
|  Idle  |---Send XFER_SEGMENT-->| In Progress |&lt;------------+
+--------+                        +-------------+
                                       |
     +---------All segments sent-------+
     |
     V
+---------+                       +--------+
| Waiting |---- Receive Final----&gt;| Stream |
| for Ack |       XFER_ACK        |  IDLE  |
+---------+                       +--------+
</artwork></figure>
        <t>
        Notes on transfer sending:
        <list>
          <t>
            Pipelining of transfers can occur when the sending entity begins 
            a new transfer while in the "Waiting for Ack" state.
          </t>
        </list>
        </t>
        <figure anchor="fig-transfer-rx-states" title="Transfer receiver states">
          <artwork xml:space="preserve">
                                         +-Receive XFER_SEGMENT-+
+--------+                               |    Send XFER_ACK     |
| Stream |                         +-------------+              |
|  Idle  |--Receive XFER_SEGMENT--&gt;| In Progress |&lt;-------------+
+--------+                         +-------------+
                                         |
     +--------Sent Final XFER_ACK--------+
     |
     V
+--------+
| Stream |
|  Idle  |
+--------+
</artwork></figure>
        <t>
          Session termination involves one entity initiating the termination
          of the session and the other entity acknowledging the termination.
          For either entity, it is the sending of the SESS_TERM message which
          transitions the session to the ending substate.
          While a session is being terminated only in-progress transfers can
          be completed and no new transfers can be started.
        </t>
        <figure anchor="fig-sessterm-init" title="Session Termination [SESSTERM] from the Initiator">
          <artwork xml:space="preserve">
+-----------+                   +---------+
|  Session  |--Send SESS_TERM-->| Session |
| Live/Idle |                   | Ending  |
+-----------+                   +---------+
</artwork></figure>
        <figure anchor="fig-sessterm-respond" title="Session Termination [SESSTERM] from the Responder">
          <artwork xml:space="preserve">
+-----------+                   +---------+
|  Session  |--Send SESS_TERM-->| Session |
| Live/Idle |                   | Ending  |
+-----------+&lt;------+           +---------+
      |             |
 Receive SESS_TERM  |
      |             |
      +-------------+
</artwork></figure>
      </section>
      <section anchor="sec-transfer-segmentation" title="Transfer Segmentation Policies">
        <t>
          Each TCPCL session allows a negotiated transfer segmentation polcy
          to be applied in each transfer direction.
          A receiving node can set the Segment MRU in its contact header to 
          determine the largest acceptable segment size, and a transmitting
          node can segment a transfer into any sizes smaller than the
          receiver's Segment MRU.
          It is a network administration matter to determine an appropriate
          segmentation policy for entities operating TCPCL, but guidance given
          here can be used to steer policy toward performance goals.
          It is also advised to consider the Segment MRU in relation to 
          chunking/packetization performed by TLS, TCP, and any intermediate
          network-layer nodes.
          <list style="hanging">
            <t hangText="Minimum Overhead:">
              For a simple network expected to exchange relatively small bundles,
              the Segment MRU can be set to be identical to the Transfer MRU which
              indicates that all transfers can be sent with a single data
              segment (i.e. no actual segmentation).
              If the network is closed and all transmitters are known to follow
              a single-segment transfer policy, then receivers can avoid the 
              necessity of segment reassembly.
              Because this CL operates over a TCP stream, which suffers from
              a form of head-of-queue blocking between messages, while one
              node is transmitting a single XFER_SEGMENT message it is not
              able to transmit any XFER_ACK or XFER_REFUSE for any associated
              received transfers.
            </t>
            <t hangText="Predictable Message Sizing:">
              In situations where the maximum message size is desired to be 
              well-controlled, the
              Segment MRU can be set to the largest acceptable size (the 
              message size less XFER_SEGMENT header size) and transmitters
              can always segment a transfer into maximum-size chunks no larger
              than the Segment MRU.
              This guarantees that any single XFER_SEGMENT will not monopolize
              the TCP stream for too long, which would prevent outgoing 
              XFER_ACK and XFER_REFUSE associated with received transfers.
            </t>
            <t hangText="Dynamic Segmentation:">
              Even after negotiation of a Segment MRU for each receiving node,
              the actual transfer segmentation only needs to guarantee than
              any individual segment is no larger than that MRU.
              In a situation where network &quot;goodput&quot; is dynamic, the transfer
              segmentation size can also be dynamic in order to control
              message transmission duration.
            </t>
          </list>
          Many other policies can be established in a TCPCL network between
          the two extremes of minimum overhead (large MRU, single-segment) and 
          predictable message sizing (small MRU, highly segmented).
          Different policies can be applied to each transfer stream to and 
          from from any particular node.
          Additionally, future header and transfer extension types can apply
          further nuance to transfer policies and policy negotiation.
        </t>
      </section>
      <section anchor="sec-protocol-example" title="Example Message Exchange">
        <t>
          The following figure depicts the protocol exchange for a
          simple session, showing the session establishment and the
          transmission of a single bundle split into three data segments (of
          lengths &quot;L1&quot;, &quot;L2&quot;, and &quot;L3&quot;) from Entity A to Entity B.
        </t>
        <t>
          Note that the sending node can transmit multiple XFER_SEGMENT
          messages without waiting for the corresponding
          XFER_ACK responses. This enables pipelining of messages on a
          transfer stream. Although this example only demonstrates a single bundle
          transmission, it is also possible to pipeline multiple XFER_SEGMENT
          messages for different bundles without necessarily waiting for
          XFER_ACK messages to be returned for each one. However,
          interleaving data segments from different bundles is not allowed.
        </t>
        <t>
          No errors or rejections are shown in this example.
        </t>
        <figure anchor="fig-contact-example"
          title="An example of the flow of protocol messages on a single TCP Session between two entities">
          <artwork xml:space="preserve">
             Entity A                             Entity B
             ========                             ========
    +-------------------------+         
    |     Contact Header      | -&gt;      +-------------------------+
    +-------------------------+      &lt;- |     Contact Header      |
                                        +-------------------------+
    +-------------------------+         
    |        SESS_INIT        | -&gt;      +-------------------------+
    +-------------------------+      &lt;- |        SESS_INIT        |
                                        +-------------------------+
    
    +-------------------------+
    |   XFER_SEGMENT (start)  | -&gt;
    |     Transfer ID [I1]    |
    |       Length [L1]       |
    |  Bundle Data 0..(L1-1)  |
    +-------------------------+
    +-------------------------+         +-------------------------+
    |     XFER_SEGMENT        | -&gt;   &lt;- |     XFER_ACK (start)    |
    |     Transfer ID [I1]    |         |     Transfer ID [I1]    |
    |       Length   [L2]     |         |        Length   [L1]    |
    |Bundle Data L1..(L1+L2-1)|         +-------------------------+
    +-------------------------+
    +-------------------------+         +-------------------------+
    |    XFER_SEGMENT (end)   | -&gt;   &lt;- |         XFER_ACK        |
    |     Transfer ID [I1]    |         |     Transfer ID [I1]    |
    |        Length   [L3]    |         |      Length   [L1+L2]   |
    |Bundle Data              |         +-------------------------+
    |    (L1+L2)..(L1+L2+L3-1)|
    +-------------------------+
                                        +-------------------------+
                                     &lt;- |      XFER_ACK (end)     |
                                        |     Transfer ID [I1]    |
                                        |     Length   [L1+L2+L3] |
                                        +-------------------------+

    +-------------------------+         
    |       SESS_TERM         | -&gt;      +-------------------------+
    +-------------------------+      &lt;- |        SESS_TERM        |
                                        +-------------------------+
</artwork>
        </figure>
      </section>
    </section>
    <section title="Session Establishment">
      <t>
        For bundle transmissions to occur using the TCPCL, a TCPCL session
        MUST first be established between communicating entities. It is up to
        the implementation to decide how and when session setup is
        triggered. For example, some sessions MAY be opened proactively
        and maintained for as long as is possible given the network
        conditions, while other sessions MAY be opened only when there is
        a bundle that is queued for transmission and the routing algorithm
        selects a certain next-hop node.
      </t>
      <section anchor="sec-tcp-connection" title="TCP Connection">
        <t>
          To establish a TCPCL session, an entity MUST first establish a TCP
          connection with the intended peer entity, typically by using the
          services provided by the operating system.
          Destination port number 4556 has been assigned by IANA as the Registered
          Port number for the TCP convergence layer.
          Other destination port numbers MAY be used per local configuration.
          Determining a peer's destination port number (if different from the
          registered TCPCL port number) is up to the implementation.
          Any source port number MAY be used for TCPCL sessions.
          Typically an operating system assigned number in the TCP Ephemeral range
          (49152-65535) is used.
        </t>
        <t>
          If the entity is unable to establish a TCP connection for any reason,
          then it is an implementation matter to determine how to handle the
          connection failure. An entity MAY decide to re-attempt to establish the
          connection. If it does so, it MUST NOT overwhelm its target with
          repeated connection attempts. Therefore, the entity MUST retry the
          connection setup no earlier than some delay time from the last attempt,
          and it SHOULD use a (binary) exponential back-off
          mechanism to increase this delay in case of repeated failures.
          The upper limit on a re-attempt back-off is implementation defined
          but SHOULD be no longer than one minute before signaling to the
          BP agent that a connection cannot be made.
        </t>
        <t>
          Once a TCP connection is established, each entity MUST immediately
          transmit a contact header over the TCP connection. The format of the
          contact header is described in
          <xref target="sec-contact-header" />.
          Because the TCPCL protocol version in use is part of the initial 
          contact header, nodes using TCPCL version 4 can coexist on a network
          with nodes using earlier TCPCL versions (with some negotiation needed
          for interoperation as described in 
          <xref target="sec-contact-negotiate" />).
        </t>
      </section>
      <section anchor="sec-contact-header" title="Contact Header">
        <t>
          Once a TCP connection is established, both parties exchange a contact
          header. This section describes the format of the contact header and
          the meaning of its fields.
        </t>
        <t>
          Upon receipt of the contact header, both entities perform the validation
          and negotiation procedures defined in
          <xref target="sec-contact-negotiate" />.
          After receiving the contact header from the other entity, either entity
          MAY refuse the session by sending a SESS_TERM message with an appropriate
          reason code.
        </t>
        <t>
          The format for the Contact Header is as follows:
        </t>
        <figure anchor="fig-contact-header" title="Contact Header Format">
          <artwork align="center" xml:space="preserve">
                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|                          magic='dtn!'                         |
+---------------+---------------+---------------+---------------+
|     Version   |   Flags       |
+---------------+---------------+
</artwork>
          </figure>
        <t>
          See
          <xref target="sec-contact-negotiate" />
          for details on the use of each
          of these contact header fields.
        </t>
        <t>
          The fields of the contact header are:
          <list style="hanging">
            <t hangText="magic:">
              A four-octet field that always contains the octet sequence 0x64
              0x74 0x6E 0x21, i.e., the text string &quot;dtn!&quot; in US-ASCII
              (and UTF-8).
            </t>
            <t hangText="Version:">
              A one-octet field value containing the value 4 (current
              version of the TCPCL).
            </t>
            <t hangText="Flags:">
              A one-octet field of single-bit flags, interpreted according to the
              descriptions in
              <xref target="tab-contact-header-flags" />.
              All reserved header flag bits SHALL be set to 0 by the sender.
              All reserved header flag bits SHALL be ignored by the receiver.
            </t>
          </list>
        </t>
        <texttable anchor="tab-contact-header-flags" title="Contact Header Flags">
          <ttcol>Name</ttcol>
          <ttcol>Code</ttcol>
          <ttcol>Description</ttcol>
          <c>CAN_TLS</c>
          <c>0x01</c>
          <c>If bit is set, indicates that the sending peer is capable of TLS security.</c>
          <c>Reserved</c>
          <c>others</c>
        </texttable>
      </section>

      <section anchor="sec-contact-negotiate" title="Contact Validation and Negotiation">
        <t>
          Upon reception of the contact header, each node follows the following
          procedures to ensure the validity of the TCPCL session and to
          negotiate values for the session parameters.
        </t>
        <t>
          If the magic string is not present or is not valid, the connection
          MUST be terminated. The intent of the magic string is to provide
          some protection against an inadvertent TCP connection by a different
          protocol than the one described in this document. To prevent a flood
          of repeated connections from a misconfigured application, an entity MAY
          elect to hold an invalid connection open and idle for some time
          before ending it.
        </t>
        <t>
          The first negotiation is on the TCPCL protocol version to use.
          The active node always sends its Contact Header first and waits for
          a response from the passive node.
          The active node can repeatedly attempt different protocol versions
          in descending order until the passive node accepts one with a
          corresponding Contact Header reply.
          Only upon response of a Contact Header from the passive node is
          the TCPCL protocol version established and parameter negotiation begun.
        </t>
        <t>
          During contact initiation, the active TCPCL node SHALL send the highest TCPCL protocol
          version on a first session attempt for a TCPCL peer.
          If the active node receives a Contact Header with a different
          protocol version than the one sent earlier on the TCP connection,
          the TCP connection SHALL be closed.
          If the active node receives a SESS_TERM message with reason of
          "Version Mismatch", that node MAY attempt further TCPCL sessions with the
          peer using earlier protocol version numbers in decreasing order.
          Managing multi-TCPCL-session state such as this is an implementation matter.
        </t>
        <t>
          If the passive node receives a contact header containing a version that is
          greater than the current version of the TCPCL that the node
          implements, then the node SHALL shutdown the session with a reason code
          of "Version mismatch".
          If the passive node receives a contact header with a
          version that is lower than the version of the protocol that the node
          implements, the node MAY either terminate the session (with a reason code
          of "Version mismatch") or the node MAY adapt its operation to
          conform to the older version of the protocol.
          The decision of version fall-back is an implementation matter.
        </t>
      </section>

      <section anchor="sec-session-security" title="Session Security">
        <t>
          This version of the TCPCL supports establishing a Transport
          Layer Security (TLS) session within an existing TCP connection.
          When TLS is used within the TCPCL it affects the entire session.
          Once established, there is no mechanism available to downgrade a
          TCPCL session to non-TLS operation.
          If this is desired, the entire TCPCL session MUST be terminated and a new
          non-TLS-negotiated session established.
        </t>
        <section anchor="sec-tls-handshake" title="TLS Handshake">
          <t>
            The use of TLS is negotated using the Contact Header as described
            in <xref target="sec-contact-negotiate" />.
            After negotiating an Enable TLS parameter of true, and before any other
            TCPCL messages are sent within the session, the session entities SHALL
            begin a TLS handshake in accordance with
            TLS 1.2 <xref target="RFC5246" /> or any successors that are 
            compatible with TLS 1.2.
            By convention, this protocol uses the node which initiated the
            underlying TCP connection as the &quot;client&quot; role
            of the TLS handshake request.
          </t>
          <t>
            The TLS handshake, if it occurs, is considered to be part of the contact
            negotiation before the TCPCL session itself is established.
            Specifics about sensitive data exposure are discussed in
            <xref target="sec-security" />.
          </t>
          <t>
            The parameters within each TLS negotiation are implementation dependent but
            any TCPCL node SHALL follow all recommended practices of 
            BCP 195 <xref target="RFC7525" />, or any updates or successors that 
            become part of BCP 195.
            When possible, the TLS handshake SHOULD include a Server Name Indication (SNI) from
            the active peer in accordance with <xref target="RFC6066" />.
            The SNI SHALL contain the same host name used to establish 
            the TCP connection.
            The passive peer MAY use the SNI host name to choose an appropriate
            server-side certificate.
            The TLS handshake SHALL request a client-side certificate to allow
            authentication of the active peer.
            The passive peer SHOULD supply a certificate within the 
            TLS handshake to allow authentication of its side of the session.
            The active peer SHOULD supply a certificate within the 
            TLS handshake to allow authentication of its side of the session.
            All certificates supplied during TLS handshake SHALL conform with
            the profile of <xref target="RFC5280" />, 
            or any updates or successors to that profile.
            When a certificate is supplied during TLS handshake, the full
            certification chain SHOULD be included unless security policy
            indicates that is unnecessary.
          </t>
          <t>
            If a TLS handshake cannot negotiate a TLS session, both entities of the TCPCL
            session SHALL close the TCP connection.
            At this point the TCPCL session has not yet been established so there
            is no TCPCL session to terminate.
            This also avoids any potential security issues assoicated with
            further TCP communication with an untrusted peer.
          </t>
          <t>
            After a TLS session is successfully established, the active peer
            SHALL send a SESS_INIT message to begin session negotiation.
            This session negotation and all subsequent messaging are secured.
          </t>
        </section>
        <section anchor="sec-tls-authentication" title="TLS Authentication">
          <t>
            Using X.509 certificates exchanged during the TLS handshake, each
            of the entities can attempt to authenticate its peer at the
            network layer (host name and address) and at the application layer
            (BP Node ID).
            The Node ID exchanged in the Session Initialization is likely to
            be used by the BP agent for making transfer and routing decisions,
            so attempting host name validation is 
            optional while attempting Node ID validation is required.
            The logic for attempting validation is separate from the
            logic for handling the result of validation, which is based on
            local security policy.
          </t>
          <t>
            Any certificate received during TLS handshake SHALL be validated
            up to one or more trusted certificate authority (CA) certificates.
            If certificate validation fails or if security policy disallows
            a certificate for any reason, the entity SHOULD terminate the session
            (with a reason code of "Contact Failure").
          </t>
          <t>
            Immediately after the TLS handshake, each side of the TCP connection
            SHOULD perform host name validation of its peer in accordance with
            <xref target="RFC6125" /> unless it is not needed by security policy.
            The active peer SHALL attempt to authenticate the host name 
            (of the passive peer) used to initiate the TCP connection.
            The active peer MAY attempt to authenticate the IP address 
            of the other side of the TCP connection.
            The passive peer SHALL attempt to authenticate the IP address of 
            the other side of the TCP connection.
            The passive peer MAY use the IP address to resolve one or more 
            host names of the active peer and attempt to authenticate those.
            If host name validation fails (including failure
            because the certificate does not contain any DNS-ID), 
            the entity SHOULD terminate the session
            (with a reason code of "Contact Failure") unless security policy
            allows an unauthticated host.
          </t>
          <t>
            Immediately before Session Parameter Negotiation, each side of
            the session SHALL perform Node ID validation of its peer as
            described below.
            Node ID validation SHALL succeed if the associated certificate
            contains a subjectAltName entry of type uniformResourceIdentifier 
            whose value matches the Node ID of the TCPCL entity.
            Unless specified otherwise by the definition of the URI scheme 
            being authenticated,
            URI matching of Node IDs SHALL use the URI comparison logic of
            <xref target="RFC3986" /> and scheme-based normalization of
            those schemes specified in <xref target="I-D.ietf-dtn-bpbis" />.
            This is similar to the URI-ID of <xref target="RFC6125" /> but does
            not require any structure to the scheme-specific-part of the URI.
            A URI scheme can refine this "exact match" logic with rules
            about how Node IDs within that scheme are to be compared with
            the certificate-authenticated URI.
            If Node ID validation fails (including failure because
            the certificate does not contain any subjectAltName URI),
            the entity SHOULD terminate the session
            (with a reason code of "Contact Failure") unless security policy
            allows an unauthticated node.
          </t>
        </section>
        <section title="Example TLS Initiation">
          <t>
            A summary of a typical TLS use is shown in the sequence in
            <xref target="fig-tls-example" />
            below.
          </t>
          <figure anchor="fig-tls-example" title="A simple visual example of TCPCL TLS Establishment between two entities">
            <artwork xml:space="preserve">
             Entity A                             Entity B
            active peer                         passive peer
    
    +-------------------------+         
    |  Open TCP Connnection   | -&gt;   
    +-------------------------+         +-------------------------+
                                     &lt;- |   Accept Connection     |
                                        +-------------------------+
    
    +-------------------------+
    |     Contact Header      | -&gt;
    +-------------------------+         +-------------------------+
                                     &lt;- |     Contact Header      |
                                        +-------------------------+
    
    +-------------------------+         +-------------------------+
    |     TLS Negotiation     | -&gt;   &lt;- |     TLS Negotiation     |
    |       (as client)       |         |       (as server)       |
    +-------------------------+         +-------------------------+
    
                      Host name validation occurs.
                   Secured TCPCL messaging can begin.
    
    +-------------------------+         +-------------------------+
    |        SESS_INIT        | -&gt;   &lt;- |        SESS_INIT        |
    +-------------------------+         +-------------------------+
    
                       Node ID validation occurs.
               Session is established, transfers can begin.
    
    +-------------------------+         +-------------------------+
    |        SESS_TERM        | -&gt;   &lt;- |        SESS_TERM        |
    +-------------------------+         +-------------------------+
</artwork>
          </figure>
        </section>
      </section>
      
      <section anchor="sec-msg-header" title="Message Header">
        <t>
          After the initial exchange of a contact header, all messages
          transmitted over the session are identified by a one-octet header
          with the following structure:
        </t>
        <figure anchor="fig-msg-header" title="Format of the Message Header">
          <artwork align="center" xml:space="preserve">
                 
 0 1 2 3 4 5 6 7 
+---------------+
| Message Type  |
+---------------+
</artwork>
        </figure>
        <t>
          The message header fields are as follows:
          <list style="hanging">
            <t hangText="Message Type:">
              Indicates the type of the message as per
              <xref target="tab-msg-types" />
              below.
              Encoded values are listed in
              <xref target="sec-iana-message-types" />.
            </t>
          </list>
        </t>
        <texttable anchor="tab-msg-types" title="TCPCL Message Types">
          <ttcol>Name</ttcol>
          <ttcol>Code</ttcol>
          <ttcol>Description</ttcol>
          <c>SESS_INIT</c>
          <c>0x07</c>
          <c>
            Contains the session parameter inputs from one of the entities,
            as described in <xref target="sec-SESS_INIT" />.
          </c>
          <c>SESS_TERM</c>
          <c>0x05</c>
          <c>
            Indicates that one of the entities participating in the session wishes to cleanly terminate the session, as described in
            <xref target="sec-termination" />.
          </c>
          <c>XFER_SEGMENT</c>
          <c>0x01</c>
          <c>
            Indicates the transmission of a segment of bundle data, as described in
            <xref target="sec-XFER_SEGMENT" />.
          </c>
          <c>XFER_ACK</c>
          <c>0x02</c>
          <c>
            Acknowledges reception of a data segment, as described in
            <xref target="sec-XFER_ACK" />.
          </c>
          <c>XFER_REFUSE</c>
          <c>0x03</c>
          <c>
            Indicates that the transmission of the current bundle SHALL be stopped, as described in
            <xref target="sec-XFER_REFUSE" />.
          </c>
          <c>KEEPALIVE</c>
          <c>0x04</c>
          <c>
            Used to keep TCPCL session active, as described in
            <xref target="sec-keepalive" />.
          </c>
          <c>MSG_REJECT</c>
          <c>0x06</c>
          <c>
            Contains a TCPCL message rejection, as described in
            <xref target="sec-MSG_REJECT" />.
          </c>
        </texttable>
      </section>

      <section anchor="sec-SESS_INIT" title="Session Initialization Message (SESS_INIT)">
        <t>
          Before a session is established and ready to transfer bundles, the
          session parameters are negotiated between the connected entities.
          The SESS_INIT message is used to convey the per-entity parameters
          which are used together to negotiate the per-session parameters
          as described in <xref target="sec-session-negotiate"/>.
        </t>
        <t>
            The format of a SESS_INIT message is as follows in
            <xref target="fig-msg-SESS_INIT-fields" />.
        </t>
        <figure anchor="fig-msg-SESS_INIT-fields" title="SESS_INIT Format">
          <artwork align="center" xml:space="preserve">
+-----------------------------+
|       Message Header        |
+-----------------------------+
|   Keepalive Interval (U16)  |
+-----------------------------+
|       Segment MRU (U64)     |
+-----------------------------+
|      Transfer MRU (U64)     |
+-----------------------------+
|     Node ID Length (U16)    |
+-----------------------------+
|    Node ID Data (variable)  |
+-----------------------------+
|      Session Extension      |
|      Items Length (U32)     |
+-----------------------------+
|      Session Extension      |
|         Items (var.)        |
+-----------------------------+
</artwork>
        </figure>
        <t>
          The fields of the SESS_INIT message are:
          <list style="hanging">
            <t hangText="Keepalive Interval:">
              A 16-bit unsigned integer indicating the interval,
              in seconds, between any subsequent messages being transmitted by the peer.
              The peer receiving this contact header uses this interval to determine
              how long to wait after any last-message transmission and a necessary
              subsequent KEEPALIVE message transmission.
            </t>
            <t hangText="Segment MRU:">
              A 64-bit unsigned integer indicating the largest allowable single-segment
              data payload size to be received in this session.
              Any XFER_SEGMENT sent to this peer SHALL have a data payload no longer
              than the peer's Segment MRU.
              The two entities of a single session MAY have different Segment MRUs, and
              no relation between the two is required.
            </t>
            <t hangText="Transfer MRU:">
              A 64-bit unsigned integer indicating the largest allowable total-bundle
              data size to be received in this session.
              Any bundle transfer sent to this peer SHALL have a Total Bundle Length
              payload no longer than the peer's Transfer MRU.
              This value can be used to perform proactive bundle fragmentation.
              The two entities of a single session MAY have different Transfer MRUs, and
              no relation between the two is required.
            </t>
            <t hangText="Node ID Length and Node ID Data:">
              Together these fields represent a variable-length text string.
              The Node ID Length is a 16-bit unsigned integer indicating the number of
              octets of Node ID Data to follow.
              A zero-length Node ID SHALL be used to indicate the lack of 
              Node ID rather than a truly empty Node ID.
              This case allows an entity to avoid exposing Node ID information on an
              untrusted network.
              A non-zero-length Node ID Data SHALL contain the UTF-8 encoded 
              Node ID of the Entity which sent the SESS_INIT message.
              Every Node ID SHALL be a URI consistent with the requirements
              of <xref target="RFC3986" /> and the URI schemes of
              <xref target="I-D.ietf-dtn-bpbis" />.
              The Node ID itself can be authenticated as described in 
              <xref target="sec-tls-authentication" />.
            </t>
            <t hangText="Session Extension Length and Session Extension Items:">
              Together these fields represent protocol extension data
              not defined by this specification.
              The Session Extension Length is the total number of octets to follow which
              are used to encode the Session Extension Item list.
              The encoding of each Session Extension Item is within a consistent data
              container as described in
              <xref target="sec-session-extension" />.
              The full set of Session Extension Items apply for the duration of
              the TCPCL session to follow.
              The order and mulitplicity of these Session Extension Items MAY be
              significant, as defined in the associated type specification(s).
            </t>
          </list>
        </t>
      </section>
      
      <section anchor="sec-session-negotiate" title="Session Parameter Negotiation">
        <t>
          An entity calculates the parameters for a TCPCL session by
          negotiating the values from its own preferences (conveyed by the
          contact header it sent to the peer) with the preferences of the peer node
          (expressed in the contact header that it received from the peer).
          The negotiated parameters defined by this specification are
          described in the following paragraphs.
        </t>
        <t>
          <list style="hanging">
            <t hangText="Transfer MTU and Segment MTU:">
              The maximum transmit unit (MTU) for whole transfers and individual segments
              are idententical to the Transfer MRU and Segment MRU, respectively,
              of the recevied contact header.
              A transmitting peer can send individual segments with any size smaller
              than the Segment MTU, depending on local policy, dynamic network
              conditions, etc.
              Determining the size of each transmitted segment is an implementation
              matter.
            </t>
            <t hangText="Session Keepalive:">
              Negotiation of the Session Keepalive parameter is performed by taking
              the minimum of this two contact headers' Keepalive Interval.
              The Session Keepalive interval is a parameter for the behavior described
              in
              <xref target="sec-keepalive" />.
            </t>
            <t hangText="Enable TLS:">
              Negotiation of the Enable TLS parameter is performed by taking
              the logical AND of the two contact headers' CAN_TLS flags.
              A local security policy is then applied to determine of the negotated value
              of Enable TLS is acceptable.
              It can be a reasonable security policy to both require or disallow
              the use of TLS depending upon the desired network flows.
              Because this state is negotiated over an unsecured medium,
              there is a risk of a TLS Stripping as described in <xref target="sec-security" />.
              If the Enable TLS state is unacceptable, the node SHALL terminate
              the session with a reason code of &quot;Contact Failure&quot;.
              Note that this contact failure reason is different than a failure 
              of TLS handshake or TLS authentication
              after an agreed-upon and acceptable Enable TLS state.
              If the negotiated Enable TLS value is true and acceptable then
              TLS negotiation feature (described in
              <xref target="sec-session-security" />) begins
              immediately following the contact header exchange.
            </t>
          </list>
        </t>
        <t>
          Once this process of parameter negotiation is completed (which includes a
          possible completed TLS handshake of the connection to use TLS),
          this protocol
          defines no additional mechanism to change the parameters of an
          established session; to effect such a change, the TCPCL session MUST
          be terminated and a new session established.
        </t>
      </section>

      <section anchor="sec-session-extension" title="Session Extension Items">
        <t>
          Each of the Session Extension Items SHALL be encoded in an identical
          Type-Length-Value (TLV) container form as indicated in
          <xref target="fig-session-extension" />.
        </t>
        <t>
          The fields of the Session Extension Item are:
          <list style="hanging">
            <t hangText="Flags:">
              A one-octet field containing generic bit flags about the Item,
              which are listed in
              <xref target="tab-session-extension-flags" />.
              All reserved header flag bits SHALL be set to 0 by the sender.
              All reserved header flag bits SHALL be ignored by the receiver.
              If a TCPCL entity receives a Session Extension Item with an unknown Item Type
              and the CRITICAL flag of 1, the entity SHALL close the
              TCPCL session with SESS_TERM reason code of &quot;Contact Failure&quot;.
              If the CRITICAL flag is 0, an entity SHALL skip over and ignore
              any item with an unknown Item Type.
            </t>
            <t hangText="Item Type:">
              A 16-bit unsigned integer field containing the type of the extension item.
              This specification does not define any extension types directly, but does
              allocate an IANA registry for such codes
              (see <xref target="sec-iana-session-extension-type" />).
            </t>
            <t hangText="Item Length:">
              A 16-bit unsigned integer field containing the number of Item Value octets
              to follow.
            </t>
            <t hangText="Item Value:">
              A variable-length data field which is interpreted according to the
              associated Item Type.
              This specification places no restrictions on an extension's use of
              available Item Value data.
              Extension specifications SHOULD avoid the use of large data lengths,
              as no bundle transfers can begin until
              the full extension data is sent.
            </t>
          </list>
        </t>
        <figure anchor="fig-session-extension" title="Session Extension Item Format">
          <artwork align="center" xml:space="preserve">
                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|  Item Flags   |           Item Type           | Item Length...|
+---------------+---------------+---------------+---------------+
| length contd. | Item Value...                                 |
+---------------+---------------+---------------+---------------+
</artwork>
        </figure>
        <texttable anchor="tab-session-extension-flags" title="Session Extension Item Flags">
          <ttcol>Name</ttcol>
          <ttcol>Code</ttcol>
          <ttcol>Description</ttcol>
          <c>CRITICAL</c>
          <c>0x01</c>
          <c>If bit is set, indicates that the receiving peer must handle the extension item.</c>
          <c>Reserved</c>
          <c>others</c>
        </texttable>
      </section>
    </section>

    <section anchor="sec-session" title="Established Session Operation">
      <t>
        This section describes the protocol operation for the duration of an
        established session, including the mechanism for transmitting
        bundles over the session.
      </t>

      <section anchor="sec-conn-upkeep" title="Upkeep and Status Messages">

        <section anchor="sec-keepalive" title="Session Upkeep (KEEPALIVE)">
          <t>
            The protocol includes a provision for transmission of KEEPALIVE
            messages over the TCPCL session to help determine if the underlying
            TCP connection has been disrupted.
          </t>
          <t>
            As described in
            <xref target="sec-contact-negotiate" />,
            a negotiated parameter of each session is the Session Keepalive interval.
            If the negotiated Session Keepalive is zero (i.e. one or both contact
            headers contains a zero Keepalive Interval), then the keepalive feature
            is disabled.
            There is no logical minimum value for the keepalive interval, but when
            used for many sessions on an open, shared network a short interval could
            lead to excessive traffic.
            For shared network use, entities SHOULD choose a keepalive interval
            no shorter than 30 seconds.
            There is no logical maximum value for the keepalive interval, but an
            idle TCP connection is liable for closure by the host operating system
            if the keepalive time is longer than tens-of-minutes.
            Entities SHOULD choose a keepalive interval no longer than 10 minutes
            (600 seconds).
          </t>
          <t>
            Note: The Keepalive Interval SHOULD NOT be chosen too short as TCP
            retransmissions MAY occur in case of packet loss. Those will have to
            be triggered by a timeout (TCP retransmission timeout (RTO)), which
            is dependent on the measured RTT for the TCP connection so that
            KEEPALIVE messages MAY experience noticeable latency.
          </t>
          <t>
            The format of a KEEPALIVE message is a one-octet message type code of
            KEEPALIVE (as described in
            <xref target="tab-msg-types" />) with no additional data.
            Both sides SHALL send a KEEPALIVE message whenever the negotiated
            interval has elapsed with no transmission of any message (KEEPALIVE
            or other).
          </t>
          <t>
            If no message (KEEPALIVE or other) has been received in a session after some
            implementation-defined time duration, then the node SHALL terminate the
            session by transmitting a SESS_TERM message (as described in
            <xref target="sec-SESS_TERM" />) with reason code "Idle Timeout".
            If configurable, the idle timeout duration SHOULD be no shorter 
            than twice the keepalive interval.
            If not configurable, the idle timeout duration SHOULD be exactly 
            twice the keepalive interval.
          </t>
        </section>

        <section anchor="sec-MSG_REJECT" title="Message Rejection (MSG_REJECT)">
          <t>
            If a TCPCL node receives a message which is unknown to it (possibly due
            to an unhandled protocol mismatch) or is inappropriate for the current
            session state (e.g. a KEEPALIVE message received after contact header
            negotiation has disabled that feature), there is a protocol-level
            message to signal this condition in the form of a MSG_REJECT reply.
          </t>
          <t>
            The format of a MSG_REJECT message is as follows in
            <xref target="fig-MSG_REJECT-fields" />.
          </t>
          <figure anchor="fig-MSG_REJECT-fields" title="Format of MSG_REJECT Messages">
            <artwork align="center" xml:space="preserve">
+-----------------------------+
|       Message Header        |
+-----------------------------+
|      Reason Code (U8)       |
+-----------------------------+
|   Rejected Message Header   |
+-----------------------------+
</artwork>
          </figure>
          <t>
            The fields of the MSG_REJECT message are:
            <list style="hanging">
              <t hangText="Reason Code:">
                A one-octet refusal reason code interpreted according to the
                descriptions in
                <xref target="tab-MSG_REJECT-reasons" />.
              </t>
              <t hangText="Rejected Message Header:">
                The Rejected Message Header is a copy of the Message Header to which the
                MSG_REJECT message is sent as a response.
              </t>
            </list>
          </t>
          <texttable anchor="tab-MSG_REJECT-reasons" title="MSG_REJECT Reason Codes">
            <ttcol>Name</ttcol>
            <ttcol>Code</ttcol>
            <ttcol>Description</ttcol>
            <c>Message Type Unknown</c>
            <c>0x01</c>
            <c>A message was received with
              a Message Type code unknown to the TCPCL node.</c>
            <c>Message Unsupported</c>
            <c>0x02</c>
            <c>A message was received but
              the TCPCL node cannot comply with the message contents.</c>
            <c>Message Unexpected</c>
            <c>0x03</c>
            <c>A message was received while the
              session is in a state in which the message is not expected.</c>
          </texttable>
        </section>
      </section>

      <section anchor="sec-transfer" title="Bundle Transfer">
        <t>
          All of the messages in this section are directly associated with transferring
          a bundle between TCPCL entities.
        </t>
        <t>
          A single TCPCL transfer results in a bundle (handled by the convergence layer
          as opaque data) being exchanged from one node to the other.
          In TCPCL a transfer is accomplished by dividing a single bundle up into
          &quot;segments&quot; based on the receiving-side Segment MRU
          (see
          <xref target="sec-contact-header" />).
          The choice of the length to use for segments is an implementation matter,
          but each segment MUST be no larger than the receiving node's maximum
          receive unit (MRU)
          (see the field "Segment MRU" of
          <xref target="sec-contact-header" />).
          The first segment for a bundle is indicated by the 'START' flag and
          the last segment is indicated by the 'END' flag.
        </t>
        <t>
          A single transfer (and by extension a single segment) SHALL NOT contain data
          of more than a single bundle.
          This requirement is imposed on the agent using the TCPCL rather than TCPCL itself.
        </t>
        <t>
          If multiple bundles are transmitted on a single TCPCL connection,
          they MUST be transmitted consecutively without interleaving of segments from multiple bundles.
        </t>
        <section anchor="sec-transfer-id" title="Bundle Transfer ID">
          <t>
            Each of the bundle transfer messages contains a Transfer ID which is
            used to correlate messages (from both sides of a transfer) for each bundle.
            A Transfer ID does not attempt to address uniqueness of the bundle data itself
            and has no relation to concepts such as bundle fragmentation.
            Each invocation of TCPCL by the bundle protocol agent, requesting transmission
            of a bundle (fragmentary or otherwise), results in the initiation of a single
            TCPCL transfer. Each transfer entails the sending of a sequence of
            some number of XFER_SEGMENT and XFER_ACK messages; all are correlated
            by the same Transfer ID.
          </t>
          <t>
            Transfer IDs from each node SHALL be unique within a single TCPCL session.
            The initial Transfer ID from each node SHALL have value zero.
            Subsequent Transfer ID values SHALL be incremented from the prior Transfer ID
            value by one.
            Upon exhaustion of the entire 64-bit Transfer ID space, the sending node
            SHALL terminate the session with SESS_TERM reason code "Resource Exhaustion".
          </t>
          <t>
            For bidirectional bundle transfers, a TCPCL node SHOULD NOT rely on any
            relation between Transfer IDs originating from each side of the TCPCL session.
          </t>
        </section>

        <section anchor="sec-XFER_SEGMENT" title="Data Transmission (XFER_SEGMENT)">
          <t>
            Each bundle is transmitted in one or more data segments.
            The format of a XFER_SEGMENT message follows in
            <xref target="fig-XFER_SEGMENT-fields" />.
          </t>
          <figure anchor="fig-XFER_SEGMENT-fields" title="Format of XFER_SEGMENT Messages">
            <artwork align="center" xml:space="preserve">
+------------------------------+
|       Message Header         |
+------------------------------+
|     Message Flags (U8)       |
+------------------------------+
|      Transfer ID (U64)       |
+------------------------------+
|     Transfer Extension       |
|      Items Length (U32)      |
|   (only for START segment)   |
+------------------------------+
|     Transfer Extension       |
|         Items (var.)         |
|   (only for START segment)   |
+------------------------------+
|      Data length (U64)       |
+------------------------------+
| Data contents (octet string) |
+------------------------------+
</artwork>
          </figure>
          <t>
            The fields of the XFER_SEGMENT message are:
            <list style="hanging">
              <t hangText="Message Flags:">
                A one-octet field of single-bit flags, interpreted according to the
                descriptions in
                <xref target="tab-XFER_SEGMENT-flags" />.
                All reserved header flag bits SHALL be zero-value by the sender.
                All reserved header flag bits SHALL be ignored by the receiver.
              </t>
              <t hangText="Transfer ID:">
                A 64-bit unsigned integer identifying the transfer being made.
              </t>
              <t hangText="Transfer Extension Length and Transfer Extension Items:">
                Together these fields represent protocol extension data
                for this specification.
                The Transfer Extension Length and Transfer Extension Item fields
                SHALL only be present when the 'START' flag is set to 1 on the message.
                The Transfer Extension Length is the total number of octets to follow which
                are used to encode the Transfer Extension Item list.
                The encoding of each Transfer Extension Item is within a consistent data
                container as described in
                <xref target="sec-transfer-extension" />.
                The full set of transfer extension items apply only to the
                assoicated single transfer.
                The order and mulitplicity of these transfer extension items MAY be
                significant, as defined in the associated type specification(s).
              </t>
              <t hangText="Data length:">
                A 64-bit unsigned integer indicating the number of octets in the
                Data contents to follow.
              </t>
              <t hangText="Data contents:">
                The variable-length data payload of the message.
              </t>
            </list>
          </t>
          <texttable anchor="tab-XFER_SEGMENT-flags" title="XFER_SEGMENT Flags">
            <ttcol>Name</ttcol>
            <ttcol>Code</ttcol>
            <ttcol>Description</ttcol>
            <c>END</c>
            <c>0x01</c>
            <c>If bit is set, indicates that this is the last segment of the transfer.</c>
            <c>START</c>
            <c>0x02</c>
            <c>If bit is set, indicates that this is the first segment of the transfer.</c>
            <c>Reserved</c>
            <c>others</c>
          </texttable>

          <t>
            The flags portion of the message contains two optional
            values in the two low-order bits, denoted 'START' and 'END' in
            <xref target="tab-XFER_SEGMENT-flags" />.
            The 'START' flag SHALL be set to 1 when transmitting the first
            segment of a transfer.
            The 'END' flag SHALL be set to 1 when transmitting the last segment of a transfer.
            In the case where an entire transfer is accomplished in a single segment,
            both the 'START' and 'END' flags SHALL be set to 1.
          </t>
          <t>
            Once a transfer of a bundle has commenced, the node MUST only
            send segments containing sequential portions of that bundle until it
            sends a segment with the 'END' flag set to 1.
            No interleaving of multiple transfers from the same node is possible
            within a single TCPCL session.
            Simultaneous transfers between two entities MAY be achieved using multiple
            TCPCL sessions.
          </t>
        </section>
        <section anchor="sec-XFER_ACK" title="Data Acknowledgments (XFER_ACK)">
          <t>
            Although the TCP transport provides reliable transfer of data between
            transport peers, the typical BSD sockets interface provides no means
            to inform a sending application of when the receiving application has
            processed some amount of transmitted data.
            Thus, after transmitting some data, the TCPCL needs an additional mechanism to
            determine whether the receiving agent has successfully received the
            segment.
            To this end, the TCPCL protocol provides feedback messaging whereby a
            receiving node transmits acknowledgments of reception of data
            segments.
          </t>
          <t>
            The format of an XFER_ACK message follows in
            <xref target="fig-XFER_ACK-fields" />.
          </t>
          <figure anchor="fig-XFER_ACK-fields" title="Format of XFER_ACK Messages">
            <artwork align="center" xml:space="preserve">
+-----------------------------+
|       Message Header        |
+-----------------------------+
|     Message Flags (U8)      |
+-----------------------------+
|      Transfer ID (U64)      |
+-----------------------------+
| Acknowledged length (U64)   |
+-----------------------------+
</artwork>
          </figure>
          <t>
            The fields of the XFER_ACK message are:
            <list style="hanging">
              <t hangText="Message Flags:">
                A one-octet field of single-bit flags, interpreted according to the
                descriptions in
                <xref target="tab-XFER_SEGMENT-flags" />.
                All reserved header flag bits SHALL be set to 0 by the sender.
                All reserved header flag bits SHALL be ignored by the receiver.
              </t>
              <t hangText="Transfer ID:">
                A 64-bit unsigned integer identifying the transfer being acknowledged.
              </t>
              <t hangText="Acknowledged length:">
                A 64-bit unsigned integer indicating the total number of octets in the
                transfer which are being acknowledged.
              </t>
            </list>
          </t>

          <t>
            A receiving TCPCL node SHALL send an XFER_ACK message in response to
            each received XFER_SEGMENT message.
            The flags portion of the XFER_ACK header SHALL be set to match the
            corresponding DATA_SEGMENT message being acknowledged.
            The acknowledged length of each XFER_ACK contains the sum of the
            data length fields of all XFER_SEGMENT messages received so far in the
            course of the indicated transfer.
            The sending node SHOULD transmit multiple XFER_SEGMENT
            messages without waiting for the corresponding
            XFER_ACK responses.
            This enables pipelining of messages on a transfer stream.
          </t>
          <t>
            For example, suppose the sending node transmits four segments of
            bundle data with lengths 100, 200, 500, and 1000, respectively.
            After receiving the first segment, the node sends an acknowledgment
            of length 100. After the second segment is received, the node sends
            an acknowledgment of length 300. The third and fourth
            acknowledgments are of length 800 and 1800, respectively.
          </t>
          <t>
          </t>
        </section>
        <section anchor="sec-XFER_REFUSE" title="Transfer Refusal (XFER_REFUSE)">
          <t>
            The TCPCL supports a mechanism by which a receiving node can indicate to
            the sender that it does not want to receive the corresponding bundle.
            To do so, upon receiving an XFER_SEGMENT message, the node MAY
            transmit a XFER_REFUSE message. As data segments and
            acknowledgments MAY cross on the wire, the bundle that is being
            refused SHALL be identified by the Transfer ID of the refusal.
          </t>
          <t>
            There is no required relation between the Transfer MRU of a TCPCL
            node (which is supposed to represent a firm limitation of what the
            node will accept) and sending of a XFER_REFUSE message.
            A XFER_REFUSE can be used in cases where the agent's bundle storage is
            temporarily depleted or somehow constrained.
            A XFER_REFUSE can also be used after the bundle header or any bundle data
            is inspected by an agent and determined to be unacceptable.
          </t>
          <t>
            A receiver MAY send an XFER_REFUSE message as soon as it receives
            any XFER_SEGMENT message.
            The sender MUST be prepared for this and MUST associate the refusal
            with the correct bundle via the Transfer ID fields.
          </t>
          <t>
            The format of the XFER_REFUSE message is as follows in
            <xref target="fig-msg-XFER_REFUSE" />.
          </t>
          <figure anchor="fig-msg-XFER_REFUSE" title="Format of XFER_REFUSE Messages">
            <artwork align="center" xml:space="preserve">
+-----------------------------+
|       Message Header        |
+-----------------------------+
|      Reason Code (U8)       |
+-----------------------------+
|      Transfer ID (U64)      |
+-----------------------------+
</artwork>
          </figure>
          <t>
            The fields of the XFER_REFUSE message are:
            <list style="hanging">
              <t hangText="Reason Code:">
                A one-octet refusal reason code interpreted according to the
                descriptions in
                <xref target="tab-XFER_REFUSE-reasons" />.
              </t>
              <t hangText="Transfer ID:">
                A 64-bit unsigned integer identifying the transfer being refused.
              </t>
            </list>
          </t>
          <texttable anchor="tab-XFER_REFUSE-reasons" title="XFER_REFUSE Reason Codes">
            <ttcol>Name</ttcol>
            <ttcol>Code</ttcol>
            <ttcol>Description</ttcol>
            <c>Unknown</c>
            <c>0x00</c>
            <c>Reason for refusal is unknown or not specified.</c>
            <c>Extension Failure</c>
            <c>0x01</c>
            <c>A failure processing the Transfer Extension Items ha occurred.</c>
            <c>Completed</c>
            <c>0x02</c>
            <c>The receiver already has the complete bundle. The sender MAY consider the bundle as completely received.</c>
            <c>No Resources</c>
            <c>0x03</c>
            <c>The receiver's resources are exhausted. The sender SHOULD apply reactive bundle fragmentation before retrying.</c>
            <c>Retransmit</c>
            <c>0x04</c>
            <c>The receiver has encountered a problem that requires the bundle to be retransmitted in its entirety.</c>
          </texttable>
          <t>
            The receiver MUST, for each transfer preceding the one to be refused,
            have either acknowledged all XFER_SEGMENTs or refused the bundle transfer.
          </t>
          <t>
            The bundle transfer refusal MAY be sent before an entire data segment is
            received. If a sender receives a XFER_REFUSE message, the sender
            MUST complete the transmission of any partially sent XFER_SEGMENT
            message. There is no way to interrupt an individual TCPCL message partway
            through sending it.
            The sender MUST NOT commence transmission of any further segments of the
            refused bundle subsequently.
            Note, however, that this requirement does not ensure
            that an entity will not receive another XFER_SEGMENT for the same bundle
            after transmitting a XFER_REFUSE message since messages MAY cross
            on the wire; if this happens, subsequent segments of the bundle
            SHALL also be refused with a XFER_REFUSE message.
          </t>
          <t>
            Note: If a bundle transmission is aborted in this way, the receiver
            MAY not receive a segment with the 'END' flag set to 1 for the
            aborted bundle. The beginning of the next bundle is identified by
            the 'START' flag set to 1, indicating the start of a new transfer, and with
            a distinct Transfer ID value.
          </t>
        </section>

          <section anchor="sec-transfer-extension" title="Transfer Extension Items">
            <t>
              Each of the Transfer Extension Items SHALL be encoded in an identical
              Type-Length-Value (TLV) container form as indicated in
              <xref target="fig-transfer-extension" />.
            </t>
            <t>
              The fields of the Transfer Extension Item are:
              <list style="hanging">
                <t hangText="Flags:">
                  A one-octet field containing generic bit flags about the Item,
                  which are listed in
                  <xref target="tab-transfer-extension-flags" />.
                  All reserved header flag bits SHALL be set to 0 by the sender.
                  All reserved header flag bits SHALL be ignored by the receiver.
                  If a TCPCL node receives a Transfer Extension Item with an unknown Item Type
                  and the CRITICAL flag is 1, the node SHALL refuse the transfer
                  with an XFER_REFUSE reason code of &quot;Extension Failure&quot;.
                  If the CRITICAL flag is 0, an entity SHALL skip over and ignore
                  any item with an unknown Item Type.
                </t>
                <t hangText="Item Type:">
                  A 16-bit unsigned integer field containing the type of the extension item.
                  This specification allocates an IANA registry for such codes
                  (see
                  <xref target="sec-iana-transfer-extension-type" />).
                </t>
                <t hangText="Item Length:">
                  A 16-bit unsigned integer field containing the number of Item Value octets
                  to follow.
                </t>
                <t hangText="Item Value:">
                  A variable-length data field which is interpreted according to the
                  associated Item Type.
                  This specification places no restrictions on an extension's use of
                  available Item Value data.
                  Extension specifications SHOULD avoid the use of large data lengths,
                  as the associated transfer cannot begin until
                  the full extension data is sent.
                </t>
              </list>
            </t>
  
            <figure anchor="fig-transfer-extension" title="Transfer Extension Item Format">
              <artwork align="center" xml:space="preserve">
                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|  Item Flags   |           Item Type           | Item Length...|
+---------------+---------------+---------------+---------------+
| length contd. | Item Value...                                 |
+---------------+---------------+---------------+---------------+
</artwork>
            </figure>
  
            <texttable anchor="tab-transfer-extension-flags" title="Transfer Extension Item Flags">
              <ttcol>Name</ttcol>
              <ttcol>Code</ttcol>
              <ttcol>Description</ttcol>
              <c>CRITICAL</c>
              <c>0x01</c>
              <c>If bit is set, indicates that the receiving peer must handle the extension item.</c>
              <c>Reserved</c>
              <c>others</c>
            </texttable>
  
            <section anchor="sec-transfer-extension-transfer-length" title="Transfer Length Extension">
              <t>
                The purpose of the Transfer Length extension is to allow entities to preemptively refuse
                bundles that would exceed their resources or to prepare storage on the
                receiving node for the upcoming bundle data.
              </t>
              <t>
                Multiple Transfer Length extension items SHALL NOT
                occur within the same transfer.
                The lack of a Transfer Length extension item in any transfer 
                SHALL NOT imply anything about the potential length of the transfer.
                The Transfer Length extension SHALL be assigned transfer extension type ID 0x0001.
              </t>
              <t>
                If a transfer occupies exactly one segment (i.e. both START and END flags are 1)
                the Transfer Length extension SHOULD NOT be present.
                The extension does not provide any additional information for
                single-segment transfers.
              </t>
              <t>
                The format of the Transfer Length data is as follows in
                <xref target="fig-Transfer-Length-fields" />.
              </t>
              <figure anchor="fig-Transfer-Length-fields" title="Format of Transfer Length data">
                <artwork align="center" xml:space="preserve">
+----------------------+
|  Total Length (U64)  |
+----------------------+
    </artwork>
              </figure>
              <t>
                The fields of the Transfer Length extension are:
                <list style="hanging">
                  <t hangText="Total Length:">
                    A 64-bit unsigned integer indicating the size of the data-to-be-transferred.
                    The Total Length field SHALL be treated as authoritative by the receiver.
                    If, for whatever reason, the actual total length of bundle data 
                    received differs from the value indicated by the
                    Total Length value, the receiver SHALL treat the transmitted data as invalid.
                  </t>
                </list>
              </t>
            </section>
          </section>
      </section>
    </section>

    <section anchor="sec-termination" title="Session Termination">
      <t>
        This section describes the procedures for ending a TCPCL session.
      </t>
      <section anchor="sec-SESS_TERM" title="Session Termination Message (SESS_TERM)">
        <t>
          To cleanly shut down a session, a SESS_TERM message SHALL be
          transmitted by either node at any point following complete
          transmission of any other message.
          When sent to initiate a termination, the REPLY flag of a SESS_TERM message
          SHALL be 0.
          Upon receiving a SESS_TERM message after not sending a SESS_TERM message in
          the same session, an entity SHALL send an acknowledging SESS_TERM message.
          When sent to acknowledge a termination, a SESS_TERM message SHALL have
          identical data content from the message being acknowledged except for
          the REPLY flag, which is set to 1 to indicate acknowledgement.
        </t>
        <t>
          After sending a SESS_TERM message, an entity MAY continue a possible in-progress
          transfer in either direction.
          After sending a SESS_TERM message, an entity SHALL NOT begin any new outgoing
          transfer for the remainder of the session.
          After receving a SESS_TERM message, an entity SHALL NOT accept any new incoming
          transfer for the remainder of the session.
        </t>
        <t>
          Instead of following a clean shutdown sequence, after transmitting a
          SESS_TERM message an entity MAY immediately close
          the associated TCP connection.
          When performing an unclean shutdown, a receiving node SHOULD
          acknowledge all received data segments before closing the TCP connection.
          Not acknowledging received segments can result in unnecessary retransmission.
          When performing an unclean shutodwn, a transmitting node SHALL treat
          either sending or receiving a SESS_TERM message
          (i.e. before the final acknowledgment) as a failure of the transfer.
          Any delay between request to close the TCP connection and actual
          closing of the connection (a &quot;half-closed&quot; state) MAY be ignored
          by the TCPCL node.
        </t>
        <t>
          The format of the SESS_TERM message is as follows in
          <xref target="fig-msg-SESS_TERM-fields" />.
        </t>
        <figure anchor="fig-msg-SESS_TERM-fields" title="Format of SESS_TERM Messages">
          <artwork align="center" xml:space="preserve">
+-----------------------------+
|       Message Header        |
+-----------------------------+
|     Message Flags (U8)      |
+-----------------------------+
|      Reason Code (U8)       |
+-----------------------------+
</artwork>
        </figure>
        <t>
          The fields of the SESS_TERM message are:
          <list style="hanging">
            <t hangText="Message Flags:">
              A one-octet field of single-bit flags, interpreted according to the
              descriptions in
              <xref target="tab-SESS_TERM-flags" />.
              All reserved header flag bits SHALL be set to 0 by the sender.
              All reserved header flag bits SHALL be ignored by the receiver.
            </t>
            <t hangText="Reason Code:">
              A one-octet refusal reason code interpreted according to the
              descriptions in
              <xref target="tab-SESS_TERM-reasons" />.
            </t>
          </list>
        </t>
        <texttable anchor="tab-SESS_TERM-flags" title="SESS_TERM Flags">
          <ttcol>Name</ttcol>
          <ttcol>Code</ttcol>
          <ttcol>Description</ttcol>
          <c>REPLY</c>
          <c>0x01</c>
          <c>If bit is set, indicates that this message is an acknowledgement of an earlier SESS_TERM message.</c>
          <c>Reserved</c>
          <c>others</c>
        </texttable>
        <texttable anchor="tab-SESS_TERM-reasons" title="SESS_TERM Reason Codes">
          <ttcol>Name</ttcol>
          <ttcol>Code</ttcol>
          <ttcol>Description</ttcol>
          <c>Unknown</c>
          <c>0x00</c>
          <c>A termination reason is not available.</c>
          <c>Idle timeout</c>
          <c>0x01</c>
          <c>The session is being closed due to idleness.</c>
          <c>Version mismatch</c>
          <c>0x02</c>
          <c>The node cannot conform to the specified TCPCL protocol version.</c>
          <c>Busy</c>
          <c>0x03</c>
          <c>The node is too busy to handle the current session.</c>
          <c>Contact Failure</c>
          <c>0x04</c>
          <c>The node cannot interpret or negotiate contact header option.</c>
          <c>Resource Exhaustion</c>
          <c>0x05</c>
          <c>The node has run into some resource limit and cannot continue the session.</c>
        </texttable>
        <t>
          A session shutdown MAY occur immediately after transmission of a
          contact header (and prior to any further message transmit).
          This MAY, for example, be used to notify
          that the node is currently not able or willing to communicate.
          However, an entity MUST always send the contact header to its peer
          before sending a SESS_TERM message.
        </t>
        <t>
          If reception of the contact header itself somehow fails (e.g. an invalid
          "magic string" is recevied), an entity SHALL close the TCP connection
          without sending a SESS_TERM message.
          If the content of the Session Extension Items data disagrees with the
          Session Extension Length (i.e. the last Item claims to use more octets
          than are present in the Session Extension Length), the reception of the
          contact header is considered to have failed.
        </t>
        <t>
          If a session is to be terminated before a protocol message
          has completed being sent, then the node MUST NOT transmit the SESS_TERM
          message but still SHALL close the TCP connection.
          Each TCPCL message is contiguous in the octet stream and has no ability
          to be cut short and/or preempted by an other message.
          This is particularly important when large segment sizes
          are being transmitted; either entire XFER_SEGMENT is sent before a SESS_TERM
          message or the connection is simply terminated mid-XFER_SEGMENT.
        </t>
      </section>
      <section anchor="sec-idle-shutdown" title="Idle Session Shutdown">
        <t>
          The protocol includes a provision for clean shutdown of idle
          sessions. Determining the length of time to wait before ending
          idle sessions, if they are to be closed at all, is an
          implementation and configuration matter.
        </t>
        <t>
          If there is a configured time to close idle links and if no TCPCL messages
          (other than KEEPALIVE messages) has been received for at least
          that amount of time, then either node MAY terminate the session by
          transmitting a SESS_TERM message indicating the reason code of "Idle
          timeout" (as described in
          <xref target="tab-SESS_TERM-reasons" />).
        </t>
      </section>
    </section>
    <section title="Implementation Status">
      <t>
        [NOTE to the RFC Editor: please remove this section before
        publication, as well as the reference to
        <xref target="RFC7942" />
        and
        <xref target="github-dtn-bpbis-tcpcl" />.]
      </t>
      <t>
        This section records the status of known implementations of the
        protocol defined by this specification at the time of posting of
        this Internet-Draft, and is based on a proposal described in
        <xref target="RFC7942" />.
        The description of implementations in this section is
        intended to assist the IETF in its decision processes in progressing
        drafts to RFCs. Please note that the listing of any individual
        implementation here does not imply endorsement by the IETF.
        Furthermore, no effort has been spent to verify the information
        presented here that was supplied by IETF contributors. This is not
        intended as, and must not be construed to be, a catalog of available
        implementations or their features. Readers are advised to note that
        other implementations can exist.
      </t>
      <t>
        An example implementation of the this draft of TCPCLv4 has been
        created as a GitHub project
        <xref target="github-dtn-bpbis-tcpcl" />
        and is intented to use as a proof-of-concept and as a possible source
        of interoperability testing.
        This example implementation uses D-Bus as the CL-BP Agent interface,
        so it only runs on hosts which provide the Python "dbus" library.
      </t>
    </section>
    <section anchor="sec-security" title="Security Considerations">
      <t>
        TCPCL can be used to provide point-to-point transport security, but does
        not provide security of data-at-rest and does not guarantee
        end-to-end bundle security.
        The bundle security mechanisms defined in <xref target="I-D.ietf-dtn-bpsec" />
        are to be used instead.
      </t>
      <t>
        When negotating whether to use TLS security as part of the contact
        header exchange, it is possible for a man-in-the-middle attacker to
        set the CAN_TLS flag to 0 on either side of the exchange.
        This leads to the "SSL Stripping" attack described in <xref target="RFC7457" />.
        If TLS is desired for use on any TCPCL network, it is strongly encouraged
        that the security policy disallow use of TCPCL when "Enable TLS" is
        negotiated to false.
        This requires that the TLS handshake occurs, regardless of the 
        policy-driven parameters of the handshake and policy-driven handling
        of the handshake outcome.
      </t>
      <t>
        Even when using TLS to secure the TCPCL session, the actual ciphersuite
        negotiated between the TLS peers MAY be insecure.
        TLS can be used to perform authentication without data confidentiality,
        for example.
        It is up to security policies within each TCPCL node to ensure that the
        negotiated TLS ciphersuite meets transport security requirements.
        This is identical behavior to STARTTLS use in
        <xref target="RFC2595" />.
      </t>
      <t>
        The certificates exchanged by TLS enable authentication of peer
        host name and Node ID, but it is possible that a peer either not
        provide a valid certificate or that the certificate does not validate
        either the host name or Node ID of the peer.
        Having a CA-validated certificate does not alone guarantee the identity
        of the network host or BP node from which the certificate is provided;
        additional validation procedures bind the host name or node ID
        based on the contents of the certificate.
        The host name validation is a weaker form of authentication, because 
        even if a peer is operating on an authenticated network host name it
        can provide an invalid Node ID and cause bundles to be "leaked" to
        an invalid node.
        Especially in DTN environments, network names and addresses of nodes
        can be time-variable so binding a certificate to a Node ID is a more 
        stable identity.
        Node ID validation ensures that the peer to which a bundle
        is transferred is in fact the node which the BP Agent expects it to be.
        It is a reasonable policy to skip host name validation if certificates
        can be guaranteed to validate the peer's Node ID.
        In circumstances where certificates can only be issued to network
        host names, Node ID validation is not possible but it could be
        reasonable to assume that a trusted host is not going to present an
        invalid Node ID.
        Trusting an authenticated host name can be feasable on a network
        secured by a private CA but is not advisable on the Internet when
        using a variety of public CAs.
      </t>
      <t>
        Another consideration for this protocol relates to denial-of-service
        attacks. An entity MAY send a large amount of data over a TCPCL
        session, requiring the receiving entity to handle the data, attempt
        to stop the flood of data by sending a XFER_REFUSE message, or
        forcibly terminate the session. This burden could cause denial of
        service on other, well-behaving sessions. There is also nothing
        to prevent a malicious entity from continually establishing sessions
        and repeatedly trying to send copious amounts of bundle data. A
        listening entity MAY take countermeasures such as ignoring TCP SYN
        messages, closing TCP connections as soon as they are established,
        waiting before sending the contact header, sending a SESS_TERM message
        quickly or with a delay, etc.
      </t>
    </section>
    <section anchor="sec-iana" title="IANA Considerations">
      <t>
        Registration procedures referred to in this section are defined in
        <xref target="RFC8126" />.
      </t>
      <t>
        Some of the registries have been defined as version specific to 
        TCPCLv4, and imports some or all codepoints from TCPCLv3.
        This was done to disambiguate the use of these codepoints
        between TCPCLv3 and TCPCLv4 while preserving the semantics of some of
        the codepoints.
      </t>
      <section anchor="sec-iana-port" title="Port Number">
        <t>
          Port number 4556 has been previously assigned as the default port for the
          TCP convergence layer in
          <xref target="RFC7242" />.
          This assignment is unchanged by protocol version 4.
          Each TCPCL entity identifies its TCPCL protocol version in its initial
          contact (see
          <xref target="sec-iana-protonum" />), so there is no ambiguity about what protocol is being used.
        </t>
        <texttable>
          <ttcol>Parameter</ttcol>
          <ttcol>Value</ttcol>
          <c>Service Name:</c>
          <c>dtn-bundle</c>
          <c>Transport Protocol(s):</c>
          <c>TCP</c>
          <c>Assignee:</c>
          <c>Simon Perreault &lt;simon@per.reau.lt&gt;</c>
          <c>Contact:</c>
          <c>Simon Perreault &lt;simon@per.reau.lt&gt;</c>
          <c>Description:</c>
          <c>DTN Bundle TCP CL Protocol</c>
          <c>Reference:</c>
          <c>
            <xref target="RFC7242" />
          </c>
          <c>Port Number:</c>
          <c>4556</c>
        </texttable>
      </section>
      <section anchor="sec-iana-protonum" title="Protocol Versions">
        <t>
          IANA has created, under the &quot;Bundle Protocol&quot; registry, a sub-
          registry titled &quot;Bundle Protocol TCP Convergence-Layer Version
          Numbers&quot; and initialize it with the following table.
          The registration procedure is RFC Required.
        </t>
        <texttable>
          <ttcol>Value</ttcol>
          <ttcol>Description</ttcol>
          <ttcol>Reference</ttcol>
          <c>0</c>
          <c>Reserved</c>
          <c>
            <xref target="RFC7242" />
          </c>
          <c>1</c>
          <c>Reserved</c>
          <c>
            <xref target="RFC7242" />
          </c>
          <c>2</c>
          <c>Reserved</c>
          <c>
            <xref target="RFC7242" />
          </c>
          <c>3</c>
          <c>TCPCL</c>
          <c>
            <xref target="RFC7242" />
          </c>
          <c>4</c>
          <c>TCPCLv4</c>
          <c>This specification.</c>
          <c>5-255</c>
          <c>Unassigned</c>
        </texttable>
      </section>

      <section anchor="sec-iana-session-extension-type" title="Session Extension Types">
        <t>EDITOR NOTE: sub-registry to-be-created upon publication of this specification.</t>
        <t>
          IANA will create, under the &quot;Bundle Protocol&quot; registry,
          a sub-registry titled
          &quot;Bundle Protocol TCP Convergence-Layer Version 4 Session Extension Types&quot;
          and initialize it with the contents of
          <xref target="tab-iana-session-extension-type" />.
          The registration procedure is Expert Review within the lower range 0x0001--0x7FFF.
          Values in the range 0x8000--0xFFFF are reserved for use on private networks
          for functions not published to the IANA.
        </t>
        <t>
          Specifications of new session extension types need to define the
          encoding of the Item Value data as well as any meaning or 
          restriction on the number of or order of instances of the type within
          an extension item list.
          Specifications need to define how the extension functions
          when no instance of the new extension type is received during
          session negotiation.
        </t>
        <t>
          Expert(s) are encouraged to be biased towards
          approving registrations unless they are abusive, frivolous, or
          actively harmful (not merely aesthetically displeasing, or
          architecturally dubious).
        </t>
        <texttable anchor="tab-iana-session-extension-type" title="Session Extension Type Codes">
          <ttcol>Code</ttcol>
          <ttcol>Session Extension Type</ttcol>
          <c>0x0000</c>
          <c>Reserved</c>
          <c>0x0001--0x7FFF</c>
          <c>Unassigned</c>
          <c>0x8000--0xFFFF</c>
          <c>Private/Experimental Use</c>
        </texttable>
      </section>

      <section anchor="sec-iana-transfer-extension-type" title="Transfer Extension Types">
        <t>EDITOR NOTE: sub-registry to-be-created upon publication of this specification.</t>
        <t>
          IANA will create, under the &quot;Bundle Protocol&quot; registry,
          a sub-registry titled
          &quot;Bundle Protocol TCP Convergence-Layer Version 4 Transfer Extension Types&quot;
          and initialize it with the contents of
          <xref target="tab-iana-transfer-extension-type" />.
          The registration procedure is Expert Review within the lower range 0x0001--0x7FFF.
          Values in the range 0x8000--0xFFFF are reserved for use on private networks
          for functions not published to the IANA.
        </t>
        <t>
          Specifications of new transfer extension types need to define the
          encoding of the Item Value data as well as any meaning or 
          restriction on the number of or order of instances of the type within
          an extension item list.
          Specifications need to define how the extension functions
          when no instance of the new extension type is received in a transfer.
        </t>
        <t>
          Expert(s) are encouraged to be biased towards
          approving registrations unless they are abusive, frivolous, or
          actively harmful (not merely aesthetically displeasing, or
          architecturally dubious).
        </t>
        <texttable anchor="tab-iana-transfer-extension-type" title="Transfer Extension Type Codes">
          <ttcol>Code</ttcol>
          <ttcol>Transfer Extension Type</ttcol>
          <c>0x0000</c>
          <c>Reserved</c>
          <c>0x0001</c>
          <c>Transfer Length Extension</c>
          <c>0x0002--0x7FFF</c>
          <c>Unassigned</c>
          <c>0x8000--0xFFFF</c>
          <c>Private/Experimental Use</c>
        </texttable>
      </section>

      <section anchor="sec-iana-message-types" title="Message Types">
        <t>EDITOR NOTE: sub-registry to-be-created upon publication of this specification.</t>
        <t>
          IANA will create, under the &quot;Bundle Protocol&quot; registry,
          a sub-registry titled
          &quot;Bundle Protocol TCP Convergence-Layer Version 4 Message Types&quot;
          and initialize it with the contents of
          <xref target="tab-iana-message-types" />.
          The registration procedure is RFC Required within the lower range 0x01--0xEF.
          Values in the range 0xF0--0xFF are reserved for use on private networks
          for functions not published to the IANA.
        </t>
        <t>
          Specifications of new message types need to define the
          encoding of the message data as well as the purpose and relationship
          of the new message to existing session/transfer state within
          the baseline message sequencing.
        </t>
        <t>
          Expert(s) are encouraged to favor new session/transfer extension types
          over new message types.
          TCPCL messages are not self-delimiting, so care must be taken 
          in introducing new message types. If an entity receives an
          unknown message type the only thing that can be done is to send a
          MSG_REJECT and close the TCP connection; 
          not even a clean termination can be done at that point.
        </t>
        <texttable anchor="tab-iana-message-types" title="Message Type Codes">
          <ttcol>Code</ttcol>
          <ttcol>Message Type</ttcol>
          <c>0x00</c>
          <c>Reserved</c>
          <c>0x01</c>
          <c>XFER_SEGMENT</c>
          <c>0x02</c>
          <c>XFER_ACK</c>
          <c>0x03</c>
          <c>XFER_REFUSE</c>
          <c>0x04</c>
          <c>KEEPALIVE</c>
          <c>0x05</c>
          <c>SESS_TERM</c>
          <c>0x06</c>
          <c>MSG_REJECT</c>
          <c>0x07</c>
          <c>SESS_INIT</c>
          <c>0x08--0xEF</c>
          <c>Unassigned</c>
          <c>0xF0--0xFF</c>
          <c>Private/Experimental Use</c>
        </texttable>
      </section>

      <section anchor="sec-iana-XFER_REFUSE-codes" title="XFER_REFUSE Reason Codes">
        <t>EDITOR NOTE: sub-registry to-be-created upon publication of this specification.</t>
        <t>
          IANA will create, under the &quot;Bundle Protocol&quot; registry,
          a sub-registry titled
          &quot;Bundle Protocol TCP Convergence-Layer Version 4 XFER_REFUSE Reason Codes&quot;
          and initialize it with the contents of
          <xref target="tab-iana-XFER_REFUSE-codes" />.
          The registration procedure is Specification Required within the lower range 0x00--0xEF.
          Values in the range 0xF0--0xFF are reserved for use on private networks
          for functions not published to the IANA.
        </t>
        <t>
          Specifications of new XFER_REFUSE reason codes need to define the
          meaning of the reason and disambiguate it with pre-exisiting 
          reasons.
          Each refusal reason needs to be usable by the receving BP Agent to make
          retransmission or re-routing decisions.
        </t>
        <t>
          Expert(s) are encouraged to be biased towards
          approving registrations unless they are abusive, frivolous, or
          actively harmful (not merely aesthetically displeasing, or
          architecturally dubious).
        </t>
        <texttable anchor="tab-iana-XFER_REFUSE-codes" title="XFER_REFUSE Reason Codes">
          <ttcol>Code</ttcol>
          <ttcol>Refusal Reason</ttcol>
          <c>0x00</c>
          <c>Unknown</c>
          <c>0x01</c>
          <c>Extension Failure</c>
          <c>0x02</c>
          <c>Completed</c>
          <c>0x03</c>
          <c>No Resources</c>
          <c>0x04</c>
          <c>Retransmit</c>
          <c>0x05--0xEF</c>
          <c>Unassigned</c>
          <c>0xF0--0xFF</c>
          <c>Private/Experimental Use</c>
        </texttable>
      </section>

      <section anchor="sec-iana-SESS_TERM-codes" title="SESS_TERM Reason Codes">
        <t>EDITOR NOTE: sub-registry to-be-created upon publication of this specification.</t>
        <t>
          IANA will create, under the &quot;Bundle Protocol&quot; registry,
          a sub-registry titled
          &quot;Bundle Protocol TCP Convergence-Layer Version 4 SESS_TERM Reason Codes&quot;
          and initialize it with the contents of
          <xref target="tab-iana-SESS_TERM-codes" />.
          The registration procedure is Specification Required within the lower range 0x00--0xEF.
          Values in the range 0xF0--0xFF are reserved for use on private networks
          for functions not published to the IANA.
        </t>
        <t>
          Specifications of new SESS_TERM reason codes need to define the
          meaning of the reason and disambiguate it with pre-exisiting 
          reasons.
          Each termination reason needs to be usable by the receving BP Agent to make
          re-connection decisions.
        </t>
        <t>
          Expert(s) are encouraged to be biased towards
          approving registrations unless they are abusive, frivolous, or
          actively harmful (not merely aesthetically displeasing, or
          architecturally dubious).
        </t>
        <texttable anchor="tab-iana-SESS_TERM-codes" title="SESS_TERM Reason Codes">
          <ttcol>Code</ttcol>
          <ttcol>Termination Reason</ttcol>
          <c>0x00</c>
          <c>Unknown</c>
          <c>0x01</c>
          <c>Idle timeout</c>
          <c>0x02</c>
          <c>Version mismatch</c>
          <c>0x03</c>
          <c>Busy</c>
          <c>0x04</c>
          <c>Contact Failure</c>
          <c>0x05</c>
          <c>Resource Exhaustion</c>
          <c>0x06--0xEF</c>
          <c>Unassigned</c>
          <c>0xF0--0xFF</c>
          <c>Private/Experimental Use</c>
        </texttable>
      </section>

      <section anchor="sec-iana-MSG_REJECT-codes" title="MSG_REJECT Reason Codes">
        <t>EDITOR NOTE: sub-registry to-be-created upon publication of this specification.</t>
        <t>
          IANA will create, under the &quot;Bundle Protocol&quot; registry,
          a sub-registry titled
          &quot;Bundle Protocol TCP Convergence-Layer Version 4 MSG_REJECT Reason Codes&quot;
          and initialize it with the contents of
          <xref target="tab-iana-MSG_REJECT-codes" />.
          The registration procedure is Specification Required within the lower range 0x01--0xEF.
          Values in the range 0xF0--0xFF are reserved for use on private networks
          for functions not published to the IANA.
        </t>
        <t>
          Specifications of new MSG_REJECT reason codes need to define the
          meaning of the reason and disambiguate it with pre-exisiting 
          reasons.
          Each rejection reason needs to be usable by the receving TCPCL Entity to make
          message sequencing and/or session termination decisions.
        </t>
        <t>
          Expert(s) are encouraged to be biased towards
          approving registrations unless they are abusive, frivolous, or
          actively harmful (not merely aesthetically displeasing, or
          architecturally dubious).
        </t>
        <texttable anchor="tab-iana-MSG_REJECT-codes" title="MSG_REJECT Reason Codes">
          <ttcol>Code</ttcol>
          <ttcol>Rejection Reason</ttcol>
          <c>0x00</c>
          <c>reserved</c>
          <c>0x01</c>
          <c>Message Type Unknown</c>
          <c>0x02</c>
          <c>Message Unsupported</c>
          <c>0x03</c>
          <c>Message Unexpected</c>
          <c>0x04--0xEF</c>
          <c>Unassigned</c>
          <c>0xF0--0xFF</c>
          <c>Private/Experimental Use</c>
        </texttable>
      </section>

    </section>

    <section anchor="sec-doc-ack" title="Acknowledgments">
      <t>
        This specification is based on comments on implementation of
        <xref target="RFC7242" />
        provided from Scott Burleigh.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.0793.xml"?>
      <?rfc include="reference.RFC.1122.xml"?>
      <?rfc include="reference.RFC.2119.xml"?>
      <?rfc include="reference.RFC.3986.xml"?>
      <?rfc include="reference.RFC.5246.xml"?>
      <?rfc include="reference.RFC.5280.xml"?>
      <?rfc include="reference.RFC.6125.xml"?>
      <?rfc include="reference.RFC.7525.xml"?>
      <?rfc include="reference.RFC.8126.xml"?>
      <?rfc include="reference.RFC.8174.xml"?>
      <?rfc include="reference.I-D.ietf-dtn-bpbis.xml"?>
    </references>
    <references title="Informative References">
      <?rfc include="reference.RFC.2595.xml"?>
      <?rfc include="reference.RFC.4838.xml"?>
      <?rfc include="reference.RFC.7242.xml"?>
      <?rfc include="reference.RFC.7457.xml"?>
      <?rfc include="reference.RFC.7942.xml"?>
      <?rfc include="reference.I-D.ietf-dtn-bpsec.xml"?>
      <reference anchor="github-dtn-bpbis-tcpcl" target="https://github.com/BSipos-RKF/dtn-bpbis-tcpcl/tree/develop">
        <front>
          <title>TCPCL Example Implementation</title>
          <author initials="B." surname="Sipos" fullname="Brian Sipos">
            <organization abbrev="RKF Engineering">
              RKF Engineering Solutions, LLC
            </organization>
          </author>
          <date />
        </front>
      </reference>
    </references>

    <section title="Significant changes from RFC7242">
      <t>
        The areas in which changes from
        <xref target="RFC7242" />
        have been made to existing headers and messages are:
        <list style="symbols">
          <t>Split contact header into pre-TLS protocol negotiation and SESS_INIT parameter negotiation. The contact header is now fixed-length.</t>
          <t>Changed contact header content to limit number of negotiated options.</t>
          <t>Added session option to negotiate maximum segment size (per each direction).</t>
          <t>Renamed "Endpoint ID" to "Node ID" to conform with BPv7 terminology.</t>
          <t>Added session extension capability.</t>
          <t>Added transfer extension capability. Moved transfer total length into an extension item.</t>
          <t>Defined new IANA registries for message / type / reason codes to allow renaming some codes for clarity.</t>
          <t>Segments of all new IANA registries are reserved for private/experimental use.</t>
          <t>Expanded Message Header to octet-aligned fields instead of bit-packing.</t>
          <t>Added a bundle transfer identification number to all bundle-related messages (XFER_SEGMENT, XFER_ACK, XFER_REFUSE).</t>
          <t>Use flags in XFER_ACK to mirror flags from XFER_SEGMENT.</t>
          <t>Removed all uses of SDNV fields and replaced with fixed-bit-length fields.</t>
          <t>Renamed SHUTDOWN to SESS_TERM to deconflict term "shutdown" related to TCP connections.</t>
          <t>Removed the notion of a re-connection delay parameter.</t>
        </list>
      </t>
      <t>
        The areas in which extensions from
        <xref target="RFC7242" />
        have been made as new messages and codes are:
        <list style="symbols">
          <t>Added contact negotiation failure SESS_TERM reason code.</t>
          <t>Added MSG_REJECT message to indicate an unknown or unhandled message was received.</t>
          <t>Added TLS session security mechanism.</t>
          <t>Added Resource Exhaustion SESS_TERM reason code.</t>
        </list>
      </t>
    </section>
  </back>
</rfc>
