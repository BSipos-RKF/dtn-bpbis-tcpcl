<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
<!ENTITY rfc2595 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2595.xml'>
<!ENTITY rfc5226 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml'>
<!ENTITY rfc5246 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml'>
<!ENTITY rfc7242 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.7242.xml'>
]>
<?rfc toc="yes"?>
<rfc ipr="trust200902" 
     category="std"
     docName="draft-ietf-dtn-tcpclv4-03"
     obsoletes="7242">
  <front>
    <title abbrev="DTN TCPCLv4">
      Delay-Tolerant Networking TCP Convergence Layer Protocol Version 4
    </title>
    <author initials="B." surname="Sipos" fullname="Brian Sipos">
      <organization abbrev="RKF Engineering">
        RKF Engineering Solutions, LLC
      </organization>
      <address>
        <postal>
          <street>7500 Old Georgetown Road</street>
          <street>Suite 1275</street>
          <city>Bethesda</city>
          <region>MD</region>
          <code>20814-6198</code>
          <country>US</country>
        </postal>
        <email>BSipos@rkf-eng.com</email>
      </address>
    </author>
    <author initials="M." surname="Demmer" fullname="Michael Demmer">
      <organization abbrev="UC Berkeley">
        University of California, Berkeley
      </organization>
      <address>
        <postal>
          <street>Computer Science Division</street>
          <street>445 Soda Hall</street>
          <city>Berkeley</city>
          <region>CA</region>
          <code>94720-1776</code>
          <country>US</country>
        </postal>
        <email>demmer@cs.berkeley.edu</email>
      </address>
    </author>
    <author initials="J." surname="Ott" fullname="Joerg Ott">
      <organization>
        Aalto University
      </organization>
      <address>
        <postal>
          <street>Department of Communications and Networking</street>
          <street>PO Box 13000</street>
          <city>Aalto</city>
          <code>02015</code>
          <country>Finland</country>
        </postal>
        <email>jo@netlab.tkk.fi</email>
      </address>
    </author>
    <author initials="S." surname="Perreault" fullname="Simon Perreault">
      <organization>
      </organization>
      <address>
        <postal>
          <street></street>
          <city>Quebec</city>
          <region>QC</region>
          <country>Canada</country>
        </postal>
        <email>simon@per.reau.lt</email>
      </address>
    </author>
    <date year="2017" month="Nov" day="13"/>
    <area>Transport</area>
    <workgroup>Delay Tolerant Networking</workgroup>

    <abstract>
      <t>
This document describes a revised protocol for the TCP-based convergence
layer (TCPCL) for Delay-Tolerant Networking (DTN).
The protocol revision is based on implementation issues in the original
TCPCL Version 3 and updates to the Bundle Protocol contents,
encodings, and convergence layer requirements in Bundle Protocol Version 7.
Specifically, the TCPCLv4 uses CBOR-encoded BPv7 bundles as its service data
unit being transported and provides a reliable transport of such bundles.
Several new IANA registries are defined for TCPCLv4 which define some
behaviors inherited from TCPCLv3 but with updated encodings and/or semantics.
      </t>
    </abstract>
  </front>
  <middle>
    <section anchor="sec-intro" title="Introduction">
      <t>
   This document describes the TCP-based convergence-layer protocol for
   Delay-Tolerant Networking.  Delay-Tolerant Networking is an end-to-
   end architecture providing communications in and/or through highly
   stressed environments, including those with intermittent
   connectivity, long and/or variable delays, and high bit error rates.
   More detailed descriptions of the rationale and capabilities of these
   networks can be found in &quot;Delay-Tolerant Network Architecture&quot;
   <xref target="RFC4838"/>.
</t><t>
   An important goal of the DTN architecture is to accommodate a wide
   range of networking technologies and environments.  The protocol used
   for DTN communications is the revised Bundle Protocol (BP)
   <xref target="I-D.ietf-dtn-bpbis"/>, an
   application-layer protocol that is used to construct a store-and-
   forward overlay network.  As described in the Bundle Protocol
   specification <xref target="I-D.ietf-dtn-bpbis"/>,
   it requires the services of a &quot;convergence-
   layer adapter&quot; (CLA) to send and receive bundles using the service of
   some &quot;native&quot; link, network, or Internet protocol.  This document
   describes one such convergence-layer adapter that uses the well-known
   Transmission Control Protocol (TCP).  This convergence layer is
   referred to as TCPCL.
</t><t>
   The locations of the TCPCL and the BP in the Internet model protocol
   stack (described in <xref target="RFC1122"/>) are shown in Figure 1.
   In particular, when BP is using TCP as its bearer with TCPCL as its 
   convergence layer, both BP and TCPCL reside at the application layer 
   of the Internet model.
 </t>
<figure anchor="fig-tcpcl-ip-stack"
     title="The Locations of the Bundle Protocol and the TCP Convergence-Layer Protocol above the Internet Protocol Stack">
<artwork>
      +-------------------------+
      |     DTN Application     | -\
      +-------------------------|   |
      |  Bundle Protocol (BP)   |   -&gt; Application Layer
      +-------------------------+   |
      | TCP Conv. Layer (TCPCL) |   |
      +-------------------------+   |
      |     TLS (optional)      | -/
      +-------------------------+
      |          TCP            | ---&gt; Transport Layer
      +-------------------------+
      |       IPv4/IPv6         | ---&gt; Network Layer
      +-------------------------+
      |   Link-Layer Protocol   | ---&gt; Link Layer
      +-------------------------+
</artwork>
</figure>
<t>
   This document describes the format of the protocol data units passed
   between entities participating in TCPCL communications.  This
   document does not address:
 </t>
 <t>
 <list style="symbols">
   <t>
     The format of protocol data units of the Bundle Protocol, as those
     are defined elsewhere in <xref target="RFC5050"/> and
     <xref target="I-D.ietf-dtn-bpbis"/>.
     This includes the concept of bundle fragmentation or bundle encapsulation.
     The TCPCL transfers bundles as opaque data blocks.
   </t><t>
     Mechanisms for locating or identifying other bundle nodes within
     an internet.
   </t>
 </list>
 </t>
</section>
<section title="Requirements Language">
<t>
   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<section anchor="sec-term-defs" title="Definitions Specific to the TCPCL Protocol">
<t>
   This section contains definitions that are interpreted to be specific
   to the operation of the TCPCL protocol, as described below.
<list style="hanging">
<t hangText="TCPCL Node:">
  A TCPCL node refers to either side of an negotiating or in-service TCPCL
  Session.
  For most TCPCL behavior, the two nodes are symmetric and there is no
  protocol distinction between them.
  Some specific behavior, particularly during negotiation, distinguishes
  between the connecting node and the connected-to node.
  For the remainder of this document, the term &quot;node&quot;
  without the prefix &quot;TCPCL&quot; refers to a TCPCL node.
</t><t hangText="TCP Connection:">
  A TCP connection refers to a transport connection
  using TCP as the transport protocol.
</t><t hangText="TCPCL Session:">
  A TCPCL session (as opposed to a TCP connection)
  is a TCPCL communication relationship between two
  bundle nodes.
  The lifetime of a TCPCL session is bound to
  the lifetime of an underlying TCP connection. Therefore, a
  TCPCL session is initiated after a bundle node establishes a TCP
  connection to for the purposes of bundle communication. 
  A TCPCL session is terminated when the TCP
  connection ends, due either to one or both nodes actively
  terminating the TCP connection or due to network errors causing
  a failure of the TCP connection. 
  For the remainder of this document, the term &quot;session&quot;
  without the prefix &quot;TCPCL&quot; refers to a TCPCL session.
</t><t hangText="Session parameters:">
  The session parameters are a set of
  values used to affect the operation of the TCPCL for a given
  session. The manner in which these parameters are conveyed
  to the bundle node and thereby to the TCPCL is implementation
  dependent. However, the mechanism by which two bundle nodes
  exchange and negotiate the values to be used for a given session
  is described in <xref target="sec-contact-negotiate"/>.
</t><t hangText="Transfer:">
  Transfer refers to the procedures and mechanisms
  (described below) for conveyance of an individual bundle from one node to
  another.
  Each transfer within TCPCLv4 is identified by a Transfer ID number
  which is unique only to a single direction within a single Session.
</t><t hangText="Reason Codes:">
  The TCPCL uses numeric codes to encode specific reasons for individual 
  failure/error message types.
  This limits the expressiveness of TCPCL error encodings, but simplifies the
  encoding of errors and allows an application policy to attempt recovery from
  expected 'failure' modes (e.g. if a Session cannot be established with USE_TLS
  disabled because of a Contact Failure shutdown, a re-attempt can be made 
  with USE_TLS enabled).
</t>
</list></t>
</section>
</section>
<section anchor="sec-prococol" title="General Protocol Description">
<t>
   The service of this protocol is the transmission of DTN bundles via
   the Transmission Control Protocol (TCP).
   This document specifies the encapsulation of bundles,
   procedures for TCP setup and teardown, and a set of messages and node
   requirements.
   The general operation of the protocol is as follows.
</t>
<section anchor="sec-protocol-session" title="TCPCL Session Overview">
<t>
   First, one node establishes a TCPCL session to the other by
   initiating a TCP connection in accordance with <xref target="RFC0793"/>.
   After setup of the TCP connection is
   complete, an initial contact header is exchanged in both directions
   to set parameters of the TCPCL session and exchange a singleton
   endpoint identifier for each node (not the singleton Endpoint
   Identifier (EID) of any application running on the node) to denote
   the bundle-layer identity of each DTN node.  This is used to assist
   in routing and forwarding messages (e.g. to prevent loops).
</t><t>
   Once the TCPCL session is established and configured in this way,
   bundles can be transferred in either direction.
   Each transfer is performed by an initialization (XFER_INIT) message followed
   by one or more logical segments of data within an  XFER_SEGMENT message.
   The choice of the length to use for segments is an implementation matter,
   but each segment must be no larger than the receiving node's maximum 
   receive unit (MRU)
   (see the field "Segment MRU" of <xref target="sec-contact-header"/>).
   The first segment for a bundle MUST set the 'START' flag, 
   and the last one MUST set the 'end' flag in the XFER_SEGMENT message flags.
</t><t>
   If multiple bundles are transmitted on a single TCPCL connection,
   they MUST be transmitted consecutively.  Interleaving data segments
   from different bundles is not allowed.  Bundle interleaving can be
   accomplished by fragmentation at the BP layer or by establishing multiple
   TCPCL sessions.
</t><t>
   A feature of this protocol is for the receiving node to send
   acknowledgments as bundle data segments arrive (XFER_ACK).  The
   rationale behind these acknowledgments is to enable the sender node
   to determine how much of the bundle has been received, so that in
   case the session is interrupted, it can perform reactive
   fragmentation to avoid re-sending the already transmitted part of the
   bundle.
   For each data segment that is
   received, the receiving node sends an XFER_ACK message containing the
   cumulative length of the bundle that has been
   received.  The sending node MAY transmit multiple XFER_SEGMENT
   messages without necessarily waiting for the corresponding
   XFER_ACK responses.  This enables pipelining of messages on a
   channel.  In addition, there is no explicit flow control on the TCPCL
   layer.
</t><t>
   Another feature is that a receiver MAY interrupt the
   transmission of a bundle at any point in time by replying with a
   XFER_REFUSE message, which causes the sender to stop transmission
   of the current bundle, after completing transmission of a partially
   sent data segment.  Note: This enables a cross-layer optimization in
   that it allows a receiver that detects that it already has received a
   certain bundle to interrupt transmission as early as possible and
   thus save transmission capacity for other bundles.
</t><t>
   For sessions that are idle, a KEEPALIVE message is
   sent at a negotiated interval.
   This is used to convey node liveness information.
</t><t>
   Finally, before sessions close, a SHUTDOWN message is sent to the
   session peer.
   A SHUTDOWN message MAY also be used to refuse a session setup by a
   peer (see <xref target="sec-contact-negotiate"/>).
   After sending a SHUTDOWN message, the sender of the
   message MAY send further acknowledgments (XFER_ACK or
   XFER_REFUSE) but no further data messages (XFER_INIT or XFER_SEGMENT).
   After receving a SHUTDOWN message and when no transfers are in-progress
   (i.e. have unacknowledged segemnts)
</t>
<t>
   There are specific messages for sending and receiving operations (in
   addition to session setup/teardown).  TCPCL is symmetric, i.e.,
   both sides can start sending data segments in a session, and one
   side's bundle transfer does not have to complete before the other
   side can start sending data segments on its own.  Hence, the protocol
   allows for a bi-directional mode of communication.
   Note that in the case of concurrent bidirectional transmission,
   acknowledgment segments MAY be interleaved with data segments.
</t>
</section>
<section anchor="sec-protocol-example" title="Example Message Exchange">
<t>
   The following figure depicts the protocol exchange for a
   simple session, showing the session establishment and the
   transmission of a single bundle split into three data segments (of
   lengths &quot;L1&quot;, &quot;L2&quot;, and &quot;L3&quot;) from Node A to Node B.
</t><t>
   Note that the sending node MAY transmit multiple XFER_SEGMENT
   messages without necessarily waiting for the corresponding
   XFER_ACK responses.  This enables pipelining of messages on a
   channel.  Although this example only demonstrates a single bundle
   transmission, it is also possible to pipeline multiple XFER_SEGMENT
   messages for different bundles without necessarily waiting for
   XFER_ACK messages to be returned for each one.  However,
   interleaving data segments from different bundles is not allowed.
</t><t>
   No errors or rejections are shown in this example.
</t>
<figure anchor="fig-contact-example"
    title="An Example of the Flow of Protocol Messages on a Single TCP Session between Two Nodes (A and B)">
<artwork>
              Node A                              Node B
              ======                              ======
    +-------------------------+         +-------------------------+
    |     Contact Header      | -&gt;   &lt;- |     Contact Header      |
    +-------------------------+         +-------------------------+
    
    +-------------------------+
    |        XFER_INIT        | -&gt;
    |     Transfer ID [I1]    |
    |    Total Length [L1]    |
    +-------------------------+
    +-------------------------+
    |   XFER_SEGMENT (start)  | -&gt;
    |     Transfer ID [I1]    |
    |       Length [L1]       |
    |  Bundle Data 0..(L1-1)  |
    +-------------------------+
    +-------------------------+         +-------------------------+
    |     XFER_SEGMENT        | -&gt;   &lt;- |     XFER_ACK (start)    |
    |     Transfer ID [I1]    |         |     Transfer ID [I1]    |
    |       Length   [L2]     |         |        Length   [L1]    |
    |Bundle Data L1..(L1+L2-1)|         +-------------------------+
    +-------------------------+
    +-------------------------+         +-------------------------+
    |    XFER_SEGMENT (end)   | -&gt;   &lt;- |         XFER_ACK        |
    |     Transfer ID [I1]    |         |     Transfer ID [I1]    |
    |        Length   [L3]    |         |      Length   [L1+L2]   |
    |Bundle Data              |         +-------------------------+
    |    (L1+L2)..(L1+L2+L3-1)|
    +-------------------------+
                                        +-------------------------+
                                     &lt;- |      XFER_ACK (end)     |
                                        |     Transfer ID [I1]    |
                                        |     Length   [L1+L2+L3] |
                                        +-------------------------+

    +-------------------------+         +-------------------------+
    |       SHUTDOWN          | -&gt;   &lt;- |         SHUTDOWN        |
    +-------------------------+         +-------------------------+
</artwork></figure>
</section>
</section>
<section title="Session Establishment">
<t>
   For bundle transmissions to occur using the TCPCL, a TCPCL session
   MUST first be established between communicating nodes.  It is up to
   the implementation to decide how and when session setup is
   triggered.  For example, some sessions MAY be opened proactively
   and maintained for as long as is possible given the network
   conditions, while other sessions MAY be opened only when there is
   a bundle that is queued for transmission and the routing algorithm
   selects a certain next-hop node.
</t><t>
   To establish a TCPCL session, a node MUST first establish a TCP
   connection with the intended peer node, typically by using the
   services provided by the operating system.
   Destination port number 4556 has been assigned by IANA as the Registered
   Port number for the TCP convergence layer.
   Other destination port numbers MAY be used per local configuration.
   Determining a peer's destination port number (if different from the 
   registered TCPCL port number) is up to the implementation.
   Any source port number MAY be used for TCPCL sessions.
   Typically an operating system assigned number in the TCP Ephemeral range
   (49152--65535) is used.
</t><t>
   If the node is unable to establish a TCP connection for any reason,
   then it is an implementation matter to determine how to handle the
   connection failure.  A node MAY decide to re-attempt to establish the
   connection.  If it does so, it MUST NOT overwhelm its target with
   repeated connection attempts.  Therefore, the node MUST retry the
   connection setup only after some delay (a 1-second minimum is
   RECOMMENDED), and it SHOULD use a (binary) exponential backoff
   mechanism to increase this delay in case of repeated failures.  In
   case a SHUTDOWN message specifying a reconnection delay is received,
   that delay is used as the initial delay.  The default initial delay
   SHOULD be at least 1 second but SHOULD be configurable since it will
   be application and network type dependent.
</t><t>
   The node MAY declare failure after one or more connection attempts
   and MAY attempt to find an alternate route for bundle data.  Such
   decisions are up to the higher layer (i.e., the BP).
</t><t>
   Once a TCP connection is established, each node MUST immediately
   transmit a contact header over the TCP connection.  The format of the
   contact header is described in <xref target="sec-contact-header"/>.
</t><t>
   Upon receipt of the contact header, both nodes perform the validation
   and negotiation procedures defined in <xref target="sec-contact-negotiate"/>
</t><t>
   After receiving the contact header from the other node, either node
   MAY also refuse the session by sending a SHUTDOWN message.  If
   session setup is refused, a reason MUST be included in the
   SHUTDOWN message.
</t>
<section anchor="sec-contact-header" title="Contact Header">
<t>
   Once a TCP connection is established, both parties exchange a contact
   header.  This section describes the format of the contact header and
   the meaning of its fields.
</t><t>
   The format for the Contact Header is as follows:
</t>
<figure anchor="fig-contact-header"
     title="Contact Header Format">
<artwork align="center">
                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|                          magic='dtn!'                         |
+---------------+---------------+---------------+---------------+
|     Version   |   Flags       |      Keepalive Interval       |
+---------------+---------------+---------------+---------------+
|                          Segment MRU...                       |
+---------------+---------------+---------------+---------------+
|                          contd.                               |
+---------------+---------------+---------------+---------------+
|                         Transfer MRU...                       |
+---------------+---------------+---------------+---------------+
|                          contd.                               |
+---------------+---------------+---------------+---------------+
|          EID Length           |             EID Data...       |
+---------------+---------------+---------------+---------------+
|                        EID Data contd.                        |
+---------------+---------------+---------------+---------------+
|                  Header Extension Length...                   |
+---------------+---------------+---------------+---------------+
|                          contd.                               |
+---------------+---------------+---------------+---------------+
|                   Header Extension Items...                   |
+---------------+---------------+---------------+---------------+
</artwork>
</figure>
<t>
    See <xref target="sec-contact-negotiate"/> for details on the use of each
    of these contact header fields.
    The fields of the contact header are:
</t><t>
<list style="hanging">
<t hangText="magic:">
    A four-octet field that always contains the octet sequence 0x64
    0x74 0x6e 0x21, i.e., the text string &quot;dtn!&quot; in US-ASCII
    (and UTF-8).
</t><t hangText="Version:">
    A one-octet field value containing the value 4 (current
    version of the protocol).
</t><t hangText="Flags:">
    A one-octet field of single-bit flags, interpreted according to the 
    descriptions in <xref target="tab-session-flags"/>.
</t><t hangText="Keepalive Interval:">
    A 16-bit unsigned integer indicating the longest allowable interval,
    in seconds, between any message being received in this session and a
    subsequent KEEPALIVE message being received.
</t><t hangText="Segment MRU:">
    A 64-bit unsigned integer indicating the largest allowable single-segment
    data payload size to be received in this session.
    Any XFER_SEGMENT sent to this peer SHALL have a data payload no longer 
    than the peer's Segment MRU.
    The two nodes of a single session MAY have different Segment MRUs, and
    no relation between the two is required.
</t><t hangText="Transfer MRU:">
    A 64-bit unsigned integer indicating the largest allowable total-bundle
    data size to be received in this session.
    Any bundle transfer sent to this peer SHALL have a Total bundle data 
    payload no longer than the peer's Transfer MRU.
    This value can be used to perform proactive bundle fragmentation.
    The two nodes of a single session MAY have different Transfer MRUs, and
    no relation between the two is required.
</t><t hangText="EID Length and EID Data:">
    Together these fields represent a variable-length text string.
    The EID Length is a 16-bit unsigned integer indicating the number of 
    octets of EID Data to follow.
    A zero EID Length SHALL be used to indicate the lack of EID rather than a
    truly empty EID.
    This case allows an node to avoid exposing EID information on an
    untrusted network.
    A non-zero-length EID Data SHALL contain the UTF-8 encoded EID of some
    singleton endpoint in which the sending node is a member, in the canonical
    format of &lt;scheme name&gt;:&lt;scheme-specific part&gt;.
    This EID encoding is consistent with <xref target="I-D.ietf-dtn-bpbis"/>.
</t><t hangText="Header Extension Length Header Extension Items:">
    Together these fields represent protocol extension data
    not defined by this specification.
    The Header Extension Length is the total number of octets to follow which
    are used to encode the Header Extension Item list.
    The encoding of each Header Extension Item is identical form as described
    in <xref target="sec-header-extension"/>.
</t>
</list>
</t>
<texttable anchor="tab-session-flags" title="Contact Header Flags">
  <ttcol>Name</ttcol><ttcol>Code</ttcol><ttcol>Description</ttcol>
  <c>CAN_TLS</c><c>0x01</c><c>If bit is set, indicates that the sending peer is capable of TLS security.</c>
  <c>Reserved</c><c>others</c>
</texttable>

<section anchor="sec-header-extension" title="Header Extension Items">
<t>
    Each of the Header Extension items SHALL be encoded in an identical 
    Type-Length-Value (TLV) container form as indicated in 
    <xref target="fig-header-extension"/>.
    The fields of the header extension item are:
</t><t>
<list style="hanging">
<t hangText="Flags:">
    A one-octet field containing generic bit flags about the item,
    which are listed in <xref target="tab-header-extension-flags"/>.
    If a TCPCL node receives an extension item with an unknown Item Type
    and the CRITICAL flag set, the node SHALL close the
    TCPCL session with SHUTDOWN reason code of &quot;Contact Failure&quot;.
    If the CRITICAL flag is not set, an node SHALL skip over and ignore
    any item with an unkonwn Item Type.
</t><t hangText="Item Type:">
    A 16-bit unsigned integer field containing the type of the extension item.
    This specification does not define any extension types directly, but does
    allocate an IANA registry for such codes
    (see <xref target="sec-iana-header-extension-type"/>).
</t><t hangText="Item Length:">
    A 32-bit unsigned integer field containing the number of Item Value octets
    to follow.
</t><t hangText="Item Value:">
    A variable-length data field which is interpreted according to the
    associated Item Type.
    This specification places no restrictions on an extensions use of available
    Item Value data.
    Extension specification SHOULD avoid the use of large data exchanges
    within the TCPCLv4 contact header as no bundle transfers can begin until
    the a full contact exchange and negotiation has been completed.
</t>
</list>
</t>

<figure anchor="fig-header-extension"
     title="Header Extention Item Format">
<artwork align="center">
                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|  Item Flags   |           Item Type           | Item Length...|
+---------------+---------------+---------------+---------------+
|    length contd.                              | Item Value... |
+---------------+---------------+---------------+---------------+
|    value contd.                                               |
+---------------+---------------+---------------+---------------+
</artwork>
</figure>

<texttable anchor="tab-header-extension-flags" title="Header Extension Item Flags">
  <ttcol>Name</ttcol><ttcol>Code</ttcol><ttcol>Description</ttcol>
  <c>CRITICAL</c><c>0x01</c><c>If bit is set, indicates that the receiving peer must handle the extension item.</c>
  <c>Reserved</c><c>others</c>
</texttable>

</section>

</section>

<section anchor="sec-contact-negotiate"
    title="Validation and Parameter Negotiation">
<t>
  Upon reception of the contact header, each node follows the following
  procedures to ensure the validity of the TCPCL session and to
  negotiate values for the session parameters.
</t><t>
  If the magic string is not present or is not valid, the connection
  MUST be terminated.  The intent of the magic string is to provide
  some protection against an inadvertent TCP connection by a different
  protocol than the one described in this document.  To prevent a flood
  of repeated connections from a misconfigured application, a node MAY
  elect to hold an invalid connection open and idle for some time
  before closing it.
</t><t>
  A connecting TCPCL node SHALL send the highest TCPCL protocol
  version on a first session attempt for a TCPCL peer.
  If a connecting node receives a SHUTDOWN message with reason of
  "Version Mismatch", that node MAY attempt further TCPCL sessions with the
  peer using earlier protocol version numbers in decreasing order.
  Managing multi-TCPCL-session state such as this is an implementation matter.
</t><t>
  If a node receives a contact header containing a version that is
  greater than the current version of the protocol that the node
  implements, then the node SHALL shutdown the session with a reason code
  of "Version mismatch".
  If a node receives a contact header with a
  version that is lower than the version of the protocol that the node
  implements, the node MAY either terminate the session (with a reason code
  of "Version mismatch"). Otherwise, the node MAY adapt its operation to 
  conform to the older version of the protocol.
  The decision of version fall-back is an implementation matter.
</t><t>
  A node calculates the parameters for a TCPCL session by
  negotiating the values from its own preferences (conveyed by the
  contact header it sent to the peer) with the preferences of the peer node
  (expressed in the contact header that it received from the peer).
  The negotatiated parameters defined by this specification are 
  described in the following paragraphs.
</t>
<t>
<list style="hanging">
<t hangText="Session Keepalive:">
    Negotiation of the Session Keepalive parameter is performed by taking
    the minimum of this two contact headers' Keepalive Interval.
    If the negotiated Session Keepalive is zero (i.e. one or both contact 
    headers contains a zero Keepalive Interval), then the keepalive feature 
    (described in <xref target="sec-keepalive"/>) is disabled.
    There is no logical minimum value for the keepalive interval, but when
    used for many sessions on an open, shared network a short interval could
    lead to excessive traffic.
    For shared network use, nodes SHOULD choose a keepalive interval
    no shorter than 30 seconds.
    There is no logical maximum value for the keepalive interval, but an
    idle TCP connection is liable for closure by the host operating system
    if the keepalive time is longer than tens-of-minutes.
    Nodes SHOULD choose a keepalive interval no longer than 10 minutes
    (600 seconds).
</t><t hangText="Enable TLS:">
  Negotiation of the Enable TLS parameter is performed by taking
  the logical AND of the two contact headers' CAN_TLS flags.
  If the negotiated Enable TLS value is true then TLS negotiation feature
  (described in <xref target="sec-session-security"/>) begins
  immediately following the contact header exchange.
  The security policy on either node MAY forbid the establishment of
  a TCPCL session for any Enable TLS result (or for any combination of local
  or peer CAN_TLS flag), in which
  case the node SHALL shutdown the session with a reason code
  of &quot;Contact Failure&quot;.
  For example, one node may disallow TCPCL sessions without TLS, while a second
  node may disallow sessions with TLS.
  Also note that this Contact Failure (of the header negotiation)
  is different than a TLS Failure (after an agreed-upon Enable TLS state).
</t>
</list>
</t>
<t>
  Once this process of parameter negotiation is completed (which includes a
  possible completed TLS handshakede of the connection to use TLS),
  this protocol
  defines no additional mechanism to change the parameters of an
  established session; to effect such a change, the TCPCL session MUST
  be terminated and a new session established.
</t>
</section>

<section anchor="sec-session-security" title="Session Security">
<t>
  This version of the TCPCL supports establishing a Transport
  Layer Security (TLS) session within an existing TCP connection.
  Negotation of whether or not to initiate TLS within a TCPCL session is 
  part of the contact header as described in <xref target="sec-contact-negotiate"/>.
  The TLS handshake, if it occurs, is considered to be part of the contact
  negotiation before the TCPCL session itself is established.
  Specifics about sensitive data exposure are discussed in
  <xref target="sec-security"/>.
</t><t>
  When TLS is used within the TCPCL it affects the entire session.
  By convention, this protocol uses the node which initiated the
  underlying TCP connection as the &quot;client&quot; role 
  of the TLS handshake request.
  Once a TLS session is established within TCPCL, there is no mechanism
  provided to end the TLS session and downgrade the session.
  If a non-TLS session is desired after a TLS session is started then
  the entire TCPCL session MUST be shutdown first.
</t>
<t>
  After negotiating an Enable TLS parameter of true, and before any other
  TCPCL messages are sent within the session, the session nodes SHALL 
  begin a TLS handshake in accordance with <xref target="RFC5246"/>.
  The parameters within each TLS negotation are implementation dependent but
  any TCPCL node SHOULD follow all recommended best practices of
  <xref target="RFC7525"/>.
</t>
      <section title="TLS Handshake Result">
        <t>
If a TLS handshake cannot negotiate a TLS session, both nodes of the TCPCL
session SHALL cause a TCPCL shutdown with reason "TLS Failure".
        </t>
        <t>
After a TLS session is successfuly established, both TCPCL nodes SHALL
re-exchange TCPCL Contact Header messages.
Any information cached from the prior Contact Header exchange SHALL be
discarded.
This re-exchange avoids man-in-the-middle attack in identical fashion to
<xref target="RFC2595"/>.
Each re-exchange header CAN_TLS flag SHALL be identical to the original header
CAN_TLS flag from the same node.
The CAN_TLS logic (TLS negotiation) SHALL NOT apply during header re-exchange.
This reinforces the fact that there is no TLS downgrade mechanism.
        </t>
      </section>
    <section title="Example TLS Initiation">
      <t>
A summary of a typical CAN_TLS usage is shown in the sequence in 
<xref target="fig-tls-example"/> below.
      </t>
<figure anchor="fig-tls-example" title="A simple visual example of TCPCL TLS Establishment between two nodes">
<artwork>
              Node A                              Node B
              ======                              ======
    
    +-------------------------+         
    |  Open TCP Connnection   | -&gt;   
    +-------------------------+         +-------------------------+
                                     &lt;- |   Accept Connection     |
                                        +-------------------------+
    
    +-------------------------+         +-------------------------+
    |     Contact Header      | -&gt;   &lt;- |     Contact Header      |
    +-------------------------+         +-------------------------+
    
    +-------------------------+         +-------------------------+
    |     TLS Negotiation     | -&gt;   &lt;- |     TLS Negotiation     |
    |       (as client)       |         |       (as server)       |
    +-------------------------+         +-------------------------+
    
    +-------------------------+         +-------------------------+
    |     Contact Header      | -&gt;   &lt;- |     Contact Header      |
    +-------------------------+         +-------------------------+
    
                    ... secured TCPCL messaging ...
    
    +-------------------------+         +-------------------------+
    |       SHUTDOWN          | -&gt;   &lt;- |         SHUTDOWN        |
    +-------------------------+         +-------------------------+
</artwork></figure>
  </section>
</section>
</section>

<section anchor="sec-session" title="Established Session Operation">
<t>
   This section describes the protocol operation for the duration of an
   established session, including the mechanism for transmitting
   bundles over the session.
</t>
<section anchor="sec-msg-codes" title="Message Type Codes">
<t>
   After the initial exchange of a contact header, all messages
   transmitted over the session are identified by a one-octet header
   with the following structure:
</t>
<figure anchor="fig-msg-header" title="Format of the Message Header">
<artwork>
                 
 0 1 2 3 4 5 6 7 
+---------------+
| Message Type  |
+---------------+
</artwork>
</figure>
<t>
The message header fields are as follows:
<list style="hanging">
<t hangText="Message Type:">
  Indicates the type of the message as per <xref target="tab-msg-types"/> below.
  Encoded values are listed in <xref target="sec-iana-message-types"/>.
</t>
</list>
</t>
<texttable anchor="tab-msg-types" title="TCPCL Message Types">
  <ttcol>Type</ttcol><ttcol>Description</ttcol>
  <c>XFER_INIT</c><c>Contains the length (in octets) of the next transfer, as described in <xref target="sec-XFER_INIT"/>.</c>
  <c>XFER_SEGMENT</c><c>Indicates the transmission of a segment of bundle data, as described in <xref target="sec-XFER_SEGMENT"/>.</c>
  <c>XFER_ACK</c><c>Acknowledges reception of a data segment, as described in <xref target="sec-XFER_ACK"/>.</c>
  <c>XFER_REFUSE</c><c>Indicates that the transmission of the current bundle SHALL be stopped, as described in <xref target="sec-XFER_REFUSE"/>.</c>
  <c>KEEPALIVE</c><c>Used to keep TCPCL session active, as described in <xref target="sec-keepalive"/>.</c>
  <c>SHUTDOWN</c><c>Indicates that one of the nodes participating in the session wishes to cleanly terminate the session, as described in <xref target="sec-termination"/>.</c>
  <c>MSG_REJECT</c><c>Contains a TCPCL message rejection, as described in <xref target="sec-MSG_REJECT"/>.</c>
</texttable>
</section>

<section anchor="sec-conn-upkeep" title="Upkeep and Status Messages">

<section anchor="sec-keepalive" title="Session Upkeep (KEEPALIVE)">
<t>
   The protocol includes a provision for transmission of KEEPALIVE
   messages over the TCPCL session to help determine if the underlying 
   TCP connection has been disrupted.
</t><t>
   As described in <xref target="sec-contact-header"/>, 
   one of the parameters in the contact
   header is the Keepalive Interval.  Both sides populate this field
   with their requested intervals (in seconds) between KEEPALIVE
   messages.
</t><t>
   The format of a KEEPALIVE message is a one-octet message type code of
   KEEPALIVE (as described in <xref target="tab-msg-types"/>) with no additional data.
   Both sides SHOULD send a KEEPALIVE message whenever the negotiated
   interval has elapsed with no transmission of any message (KEEPALIVE
   or other).
</t><t>
   If no message (KEEPALIVE or other) has been received for at least
   twice the Keepalive Interval, then either party MAY terminate the
   session by transmitting a one-octet SHUTDOWN message (as described in
   <xref target="sec-SHUTDOWN"/>, with reason code "Idle Timeout") and by closing the session.
</t><t>
   Note: The Keepalive Interval SHOULD not be chosen too short as TCP
   retransmissions MAY occur in case of packet loss.  Those will have to
   be triggered by a timeout (TCP retransmission timeout (RTO)), which
   is dependent on the measured RTT for the TCP connection so that
   KEEPALIVE messages MAY experience noticeable latency.
</t>
</section>

<section anchor="sec-MSG_REJECT" title="Message Rejection (MSG_REJECT)">
<t>
    If a TCPCL node receives a message which is unknown to it (possibly due
    to an unhandled protocol mismatch) or is inappropriate for the current 
    session state (e.g. a KEEPALIVE message received after contact header
    negotation has disabled that feature), there is a protocol-level
    message to signal this condition in the form of a MSG_REJECT reply.
</t><t>
    The format of a MSG_REJECT message follows:
</t>
<figure anchor="fig-MSG_REJECT-fields" title="Format of MSG_REJECT Messages">
<artwork align="center">
+-----------------------------+
|       Message Header        |
+-----------------------------+
|      Reason Code (U8)       |
+-----------------------------+
|   Rejected Message Header   |
+-----------------------------+
</artwork>
</figure>
<t>
The fields of the MSG_REJECT message are:
<list style="hanging">
<t hangText="Reason Code:">
    A one-octet refusal reason code interpreted according to the 
    descriptions in <xref target="tab-reject-reasons"/>.
</t>
<t hangText="Rejected Message Header:">
    The Rejected Message Header is a copy of the Message Header to which the
    MSG_REJECT message is sent as a response.
</t>
</list>
</t>
<texttable anchor="tab-reject-reasons" title="MSG_REJECT Reason Codes">
  <ttcol>Name</ttcol><ttcol>Code</ttcol><ttcol>Description</ttcol>
  <c>Message Type Unknown</c><c>0x01</c><c>A message was received with
  a Message Type code unknown to the TCPCL node.</c>
  <c>Message Unsupported</c><c>0x02</c><c>A message was received but
  the TCPCL node cannot comply with the message contents.</c>
  <c>Message Unexpected</c><c>0x03</c><c>A message was received while the
  session is in a state in which the message is not expected.</c>
</texttable>
</section>
</section>

<section anchor="sec-transfer" title="Bundle Transfer">
<t>
All of the message in this section are directly associated with transfering
a bundle between TCPCL nodes.
</t><t>
A single TCPCL transfer results in a bundle (handled by the convergence layer
as opaque data) being exchanged from one node to the other.
In TCPCL a transfer is accomplished by dividing a single bundle up into 
&quot;segments&quot; based on the receiving-side Segment MRU
(see <xref target="sec-contact-header"/>).
</t><t>
A single transfer (and by extension a single segment) SHALL NOT contain data
of more than a single bundle. This requirement is imposed on the agent using
the TCPCL rather than TCPCL itself.
</t>
<section anchor="sec-transfer-id" title="Bundle Transfer ID">
<t>
Each of the bundle transfer messages contains a Transfer ID number which is
used to correlate messages originating from sender and receiver of a bundle.
A Transfer ID does not attempt to address uniqueness of the bundle data itself
and has no relation to concepts such as bundle fragmentation.
Each invocation of TCPCL by the bundle protocol agent, requesting transmission 
of a bundle (fragmentary or otherwise), results in the initiation of a single 
TCPCL transfer. Each transfer entails the sending of a XFER_INIT message 
and some number of XFER_SEGMENT and XFER_ACK messages; all are correlated
by the same Transfer ID.
</t><t>
Transfer IDs from each node SHALL be unique within a single TCPCL session.
The initial Transfer ID from each node SHALL have value zero.
Subsequent Transfer ID values SHALL be incremented from the prior Transfer ID
value by one.
Upon exhaustion of the entire 64-bit Transfer ID space, the sending node
SHALL terminate the session with SHUTDOWN reason code "Resource Exhaustion".
</t><t>
For bidirectional bundle transfers, a TCPCL node SHOULD NOT rely on any
relation between Transfer IDs originating from each side of the TCPCL session.
</t>
</section>

<section anchor="sec-XFER_INIT" title="Transfer Initialization (XFER_INIT)">
<t>
   The XFER_INIT message contains the total length, in octets, of the bundle data
   in the associated transfer.
   The total length is formatted as a 64-bit unsigned integer.
</t><t>
   The purpose of the XFER_INIT message is to allow nodes to preemptively refuse
   bundles that would exceed their resources or to prepare storage on the
   receiving node for the upcoming bundle data.
   See <xref target="sec-XFER_REFUSE"/> for details on when refusal based
   on XFER_INIT content is acceptable.
</t><t>
   The Total Bundle Length field within a XFER_INIT message SHALL be treated
   as authoritative by the receiver. If, for whatever reason, the actual
   total length of bundle data received differs from the value indicated by the
   XFER_INIT message, the receiver SHOULD treat the transmitted data as invalid.
</t><t>
   The format of the XFER_INIT message is as follows:
</t>
<figure anchor="fig-XFER_INIT-fields" title="Format of XFER_INIT Messages">
<artwork align="center">
+-----------------------------+
|       Message Header        |
+-----------------------------+
|      Transfer ID (U64)      |
+-----------------------------+
|  Total bundle length (U64)  |
+-----------------------------+
</artwork>
</figure>
<t>
The fields of the XFER_INIT message are:
<list style="hanging">
<t hangText="Transfer ID:">
    A 64-bit unsigned integer identifying the transfer about to begin.
</t>
<t hangText="Total bundle length:">
    A 64-bit unsigned integer indicating the size of the data-to-be-transferred.
</t>
</list>
</t>
<t>
   An XFER_INIT message SHALL be sent immediately before transmission of any
   XFER_SEGMENT messages for each Transfer ID.
   XFER_INIT messages MUST NOT be sent unless the next XFER_SEGMENT message 
   has the 'START' bit set to &quot;1&quot;
   (i.e., just before the start of a new transfer).
</t><t>
   A receiver MAY send a BUNDLE_REFUSE message as soon as it receives a
   XFER_INIT message without waiting for the next XFER_SEGMENT message.
   The sender MUST be prepared for this and MUST associate the refusal
   with the correct bundle via the Transfer ID fields.
</t>
</section>

<section anchor="sec-XFER_SEGMENT" title="Data Transmission (XFER_SEGMENT)">
<t>
   Each bundle is transmitted in one or more data segments.
   The format of a XFER_SEGMENT message follows in 
   <xref target="fig-XFER_SEGMENT-fields"/>.
</t>
<figure anchor="fig-XFER_SEGMENT-fields" title="Format of XFER_SEGMENT Messages">
<artwork align="center">
+------------------------------+
|       Message Header         |
+------------------------------+
|     Message Flags (U8)       |
+------------------------------+
|      Transfer ID (U64)       |
+------------------------------+
|      Data length (U64)       |
+------------------------------+
| Data contents (octet string) |
+------------------------------+
</artwork>
</figure>
<t>
The fields of the XFER_SEGMENT message are:
<list style="hanging">
<t hangText="Message Flags:">
    A one-octet field of single-bit flags, interpreted according to the 
    descriptions in <xref target="tab-XFER_SEGMENT-flags"/>.
</t>
<t hangText="Transfer ID:">
    A 64-bit unsigned integer identifying the transfer being made.
</t>
<t hangText="Data length:">
    A 64-bit unsigned integer indicating the number of octets in the
    Data contents to follow.
</t>
<t hangText="Data contents:">
    The variable-length data payload of the message.
</t>
</list>
</t>
<texttable anchor="tab-XFER_SEGMENT-flags" title="XFER_SEGMENT Flags">
  <ttcol>Name</ttcol><ttcol>Code</ttcol><ttcol>Description</ttcol>
  <c>END</c><c>0x01</c><c>If bit is set, indicates that this is the last segment of the transfer.</c>
  <c>START</c><c>0x02</c><c>If bit is set, indicates that this is the first segment of the transfer.</c>
  <c>Reserved</c><c>others</c>
</texttable>

<t>
   The flags portion of the message contains two optional
   values in the two low-order bits, denoted 'START' and 'END' in <xref target="tab-XFER_SEGMENT-flags"/>.
   The 'START' bit MUST be set to one if it precedes the transmission of the first
   segment of a transfer.
   The 'END' bit MUST be set to one when transmitting the last segment of a transfer.
   In the case where an entire transfer is accomplished in a single segment,
   both the 'START' and 'END' bits MUST be set to one.
</t><t>
   Once a transfer of a bundle has commenced, the node MUST only
   send segments containing sequential portions of that bundle until it
   sends a segment with the 'END' bit set.
   No interleaving of multiple transfers from the same node is possible
   within a single TCPCL session.
   Simultaneous transfers between two nodes MAY be achieved using multiple
   TCPCL sessions.
</t>
</section>
<section anchor="sec-XFER_ACK" title="Data Acknowledgments (XFER_ACK)">
<t>
   Although the TCP transport provides reliable transfer of data between
   transport peers, the typical BSD sockets interface provides no means
   to inform a sending application of when the receiving application has
   processed some amount of transmitted data.  Thus, after transmitting
   some data, a Bundle Protocol agent needs an additional mechanism to
   determine whether the receiving agent has successfully received the
   segment.
   To this end, the TCPCL protocol provides feedback messaging whereby a
   receiving node transmits acknowledgments of reception of data
   segments.
</t><t>
   The format of an XFER_ACK message follows in 
   <xref target="fig-XFER_ACK-fields"/>.
</t>
<figure anchor="fig-XFER_ACK-fields" title="Format of XFER_ACK Messages">
<artwork align="center">
+-----------------------------+
|       Message Header        |
+-----------------------------+
|     Message Flags (U8)      |
+-----------------------------+
|      Transfer ID (U64)      |
+-----------------------------+
| Acknowledged length (U64)   |
+-----------------------------+
</artwork>
</figure>
<t>
The fields of the XFER_ACK message are:
<list style="hanging">
<t hangText="Message Flags:">
    A one-octet field of single-bit flags, interpreted according to the 
    descriptions in <xref target="tab-XFER_SEGMENT-flags"/>.
</t>
<t hangText="Transfer ID:">
    A 64-bit unsigned integer identifying the transfer being acknowledged.
</t>
<t hangText="Acknowledged length:">
    A 64-bit unsigned integer indicating the total number of octets in the
    transfer which are being acknowledged.
</t>
</list>
</t>

<t>
   A receiving TCPCL endpoing SHALL send an XFER_ACK message in response to
   each received XFER_SEGMENT message.
   The flags portion of the XFER_ACK header SHALL be set to match the
   corresponding DATA_SEGMENT message being acknowledged.
   The acknowledged length of each XFER_ACK contains the sum of the 
   data length fields of all XFER_SEGMENT messages received so far in the
   course of the indicated transfer.
</t><t>
   For example, suppose the sending node transmits four segments of
   bundle data with lengths 100, 200, 500, and 1000, respectively.
   After receiving the first segment, the node sends an acknowledgment
   of length 100.  After the second segment is received, the node sends
   an acknowledgment of length 300.  The third and fourth
   acknowledgments are of length 800 and 1800, respectively.
</t><t>
</t>
</section>
<section anchor="sec-XFER_REFUSE" title="Transfer Refusal (XFER_REFUSE)">
<t>
   The TCPCL supports an mechanism by which a receiving node can indicate to
   the sender that it does not want to receive the corresponding bundle.
   To do so, upon receiving a XFER_INIT or XFER_SEGMENT message, the node MAY
   transmit a XFER_REFUSE message.  As data segments and
   acknowledgments MAY cross on the wire, the bundle that is being
   refused SHALL be identified by the Transfer ID of the refusal.
</t><t>
   There is no required relation between the Transfer MRU of a TCPCL
   node (which is supposed to represent a firm limitation of what the
   node will accept) and sending of a XFER_REFUSE message.
   A XFER_REFUSE can be used in cases where the agent's bundle storage is
   temporarily depleted or somehow constrained.
   A XFER_REFUSE can also be used after the bundle header or any bundle data
   is inspected by an agent and determined to be unacceptable.
</t><t>
   The format of the XFER_REFUSE message is as follows:
</t>
<figure anchor="fig-msg-XFER_REFUSE" title="Format of XFER_REFUSE Messages">
<artwork align="center">
+-----------------------------+
|       Message Header        |
+-----------------------------+
|      Reason Code (U8)       |
+-----------------------------+
|      Transfer ID (U64)      |
+-----------------------------+
</artwork>
</figure>
<t>
The fields of the XFER_REFUSE message are:
<list style="hanging">
<t hangText="Reason Code:">
    A one-octet refusal reason code interpreted according to the 
    descriptions in <xref target="tab-rcode-values"/>.
</t>
<t hangText="Transfer ID:">
    A 64-bit unsigned integer identifying the transfer being refused.
</t>
</list>
</t>
<texttable anchor="tab-rcode-values" title="XFER_REFUSE Reason Codes">
  <ttcol>Name</ttcol><ttcol>Semantics</ttcol>
  <c>Unknown</c><c>Reason for refusal is unknown or not specified.</c>
  <c>Completed</c><c>The receiver already has the complete bundle. The sender MAY consider the bundle as completely received.</c>
  <c>No Resources</c><c>The receiver's resources are exhausted. The sender SHOULD apply reactive bundle fragmentation before retrying.</c>
  <c>Retransmit</c><c>The receiver has encountered a problem that requires the bundle to be retransmitted in its entirety.</c>
</texttable>
<t>
   The receiver MUST, for each transfer preceding the one to be refused,
   have either acknowledged all XFER_SEGMENTs or refused the bundle transfer.
</t><t>
   The bundle transfer refusal MAY be sent before an entire data segment is
   received.  If a sender receives a XFER_REFUSE message, the sender
   MUST complete the transmission of any partially sent XFER_SEGMENT
   message. There is no way to interrupt an individual TCPCL message partway
   through sending it.
   The sender MUST NOT commence transmission of any further segments of the
   refused bundle subsequently.
   Note, however, that this requirement does not ensure
   that a node will not receive another XFER_SEGMENT for the same bundle
   after transmitting a XFER_REFUSE message since messages MAY cross
   on the wire; if this happens, subsequent segments of the bundle
   SHOULD also be refused with a XFER_REFUSE message.
</t><t>
   Note: If a bundle transmission is aborted in this way, the receiver
   MAY not receive a segment with the 'END' flag set to '1' for the
   aborted bundle.  The beginning of the next bundle is identified by
   the 'START' bit set to '1', indicating the start of a new transfer, and with
   a distinct Transfer ID value.
</t>
</section>

</section>
</section>

<section anchor="sec-termination" title="Session Termination">
<t>
   This section describes the procedures for ending a TCPCL session.
</t>
<section anchor="sec-SHUTDOWN" title="Shutdown Message (SHUTDOWN)">
<t>
   To cleanly shut down a session, a SHUTDOWN message MUST be
   transmitted by either node at any point following complete
   transmission of any other message.
   A receiving node SHOULD acknowledge all received data segments
   before sending a SHUTDOWN message to end the session.
   A transmitting node SHALL treat a SHUTDOWN message received mid-transfer
   (i.e. before the final acknowledgement) as a failure of the transfer.
</t><t>
   After transmitting a SHUTDOWN message, an node MAY immediately close
   the associated TCP connection.
   Once the SHUTDOWN message is sent, any further received data on the TCP
   connection SHOULD be ignored.
   Any delay between request to terminate the TCP connection and actual
   closing of the connection (a &quot;half-closed&quot; state) MAY be ignored
   by the TCPCL node.
</t><t>
   The format of the SHUTDOWN message is as follows:
</t>
<figure anchor="fig-msg-SHUTDOWN" title="Format of SHUTDOWN Messages">
<artwork align="center">
+-----------------------------------+
|          Message Header           |
+-----------------------------------+
|         Message Flags (U8)        |
+-----------------------------------+
|     Reason Code (optional U8)     |
+-----------------------------------+
| Reconnection Delay (optional U16) |
+-----------------------------------+
</artwork>
</figure>
<t>
The fields of the SHUTDOWN message are:
<list style="hanging">
<t hangText="Message Flags:">
    A one-octet field of single-bit flags, interpreted according to the 
    descriptions in <xref target="tab-SHUTDOWN-flags"/>.
</t>
<t hangText="Reason Code:">
    A one-octet refusal reason code interpreted according to the 
    descriptions in <xref target="tab-shutdown-reasons"/>.
    The Reason Code is present or absent as indicated by one of the flags.
</t>
<t hangText="Reconnection Delay:">
    A 16-bit unsigned integer indicating the desired delay until further
    TCPCL sessions to the sending node.
    The Reconnection Delay is present or absent as indicated by one of the flags.
</t>
</list>
</t>
<texttable anchor="tab-SHUTDOWN-flags" title="SHUTDOWN Flags">
  <ttcol>Name</ttcol><ttcol>Code</ttcol><ttcol>Description</ttcol>
  <c>D</c><c>0x01</c><c>If bit is set, indicates that a Reconnection Delay field is present.</c>
  <c>R</c><c>0x02</c><c>If bit is set, indicates that a Reason Code field is present.</c>
  <c>Reserved</c><c>others</c>
</texttable>
<t>
   It is possible for a node to convey additional information regarding
   the reason for session termination.  To do so, the node MUST set
   the 'R' bit in the message flags and transmit a one-octet
   reason code immediately following the message header.  The specified
   values of the reason code are:
</t>
<texttable anchor="tab-shutdown-reasons" title="SHUTDOWN Reason Codes">
  <ttcol>Name</ttcol><ttcol>Description</ttcol>
  <c>Idle timeout</c><c>The session is being closed due to idleness.</c>
  <c>Version mismatch</c><c>The node cannot conform to the specified TCPCL protocol version.</c>
  <c>Busy</c><c>The node is too busy to handle the current session.</c>
  <c>Contact Failure</c><c>The node cannot interpret or negotiate contact header option.</c>
  <c>TLS Failure</c><c>The node failed to negotiate TLS session and cannot continue the session.</c>
  <c>Resource Exhaustion</c><c>The node has run into some resoure limit and cannot continue the session.</c>
</texttable>
<t>
   It is also possible to convey a requested reconnection delay to
   indicate how long the other node MUST wait before attempting
   session re-establishment.  To do so, the node sets the 'D' bit in
   the message flags and then transmits an 16-bit unsigned integer
   specifying the
   requested delay, in seconds, following the message header (and
   optionally, the SHUTDOWN reason code).  The value 0 SHALL be
   interpreted as an infinite delay, i.e., that the connecting node MUST
   NOT re-establish the session.  In contrast, if the node does not
   wish to request a delay, it SHOULD omit the reconnection delay field
   (and set the 'D' bit to zero).
</t><t>
   A session shutdown MAY occur immediately after TCP connection
   establishment or reception of a contact header (and prior to any
   further data exchange).  This MAY, for example, be used to notify
   that the node is currently not able or willing to communicate.
   However, a node MUST always send the contact header to its peer
   before sending a SHUTDOWN message.
</t><t>
   If either node terminates a session prematurely in this manner, it
   SHOULD send a SHUTDOWN message and MUST indicate a reason code unless
   the incoming connection did not include the magic string.
   If the magic string was not present, a node SHOULD close the TCP connection
   without sending a SHUTDOWN message.
   If a node does not want its peer to reopen a connection immediately, it
   SHOULD set the 'D' bit in the flags and include a reconnection delay
   to indicate when the peer is allowed to attempt another session
   setup.
</t><t>
   If a session is to be terminated before a protocol message
   has completed being sent, then the node MUST NOT transmit the SHUTDOWN
   message but still SHOULD close the TCP connection.
   Each TCPCL message is contiguous in the octet stream and has no ability
   to be cut short and/or preempted by an other message.
   This is particularly important when large segment sizes
   are being transmitted; either entire XFER_SEGMENT is sent before a SHUTDOWN
   message or the connection is simply termiated mid-XFER_SEGMENT.
</t>
</section>
<section anchor="sec-idle-shutdown" title="Idle Session Shutdown">
<t>
   The protocol includes a provision for clean shutdown of idle
   sessions.  Determining the length of time to wait before closing
   idle sessions, if they are to be closed at all, is an
   implementation and configuration matter.
</t><t>
   If there is a configured time to close idle links and if no bundle
   data (other than KEEPALIVE messages) has been received for at least
   that amount of time, then either node MAY terminate the session by
   transmitting a SHUTDOWN message indicating the reason code of 'Idle
   timeout' (as described in <xref target="tab-shutdown-reasons"/>).
</t>
</section>
</section>
<section anchor="sec-security" title="Security Considerations">
<t>
   One security consideration for this protocol relates to the fact that
   nodes present their endpoint identifier as part of the contact
   header exchange.  It would be possible for a node to fake this value
   and present the identity of a singleton endpoint in which the node is
   not a member, essentially masquerading as another DTN node.  If this
   identifier is used outside of a TLS-secured session or 
   without further verification as a means to
   determine which bundles are transmitted over the session, then the
   node that has falsified its identity would be able to obtain bundles
   that it otherwise would not have.
   Therefore, a node SHALL NOT use the EID value of an unsecured contact header
   to derive a peer node's identity unless it can corroborate it via other
   means.
   When TCPCL session security is mandatory, an endpoint SHALL transmit initial
   unsecured contact header values indicated in
   <xref target="tab-empty-contact"/> in order. These values avoid unnecessarily
   leaking endpoing parameters and will be ignored when secure contact header
   re-exchange occurs.
</t>
<texttable anchor="tab-empty-contact" title="Recommended Unsecured Contact Header">
  <ttcol>Parameter</ttcol><ttcol>Value</ttcol>
  <c>Flags</c><c>The USE_TLS flag is set.</c>
  <c>Keepalive Interval</c><c>Zero, indicating no keepalive.</c>
  <c>Segment MRU</c><c>Zero, indicating all segments are refused.</c>
  <c>Transfer MRU</c><c>Zero, indicating all transfers are refused.</c>
  <c>EID</c><c>Empty, indating lack of EID.</c>
</texttable>
<t>
   TCPCL can be used to provide point-to-point transport security, but does
   not provide security of data-at-rest and does not guarantee
   end-to-end bundle security.
   The mechanisms defined in <xref target="RFC6257"/> and 
   <xref target="I-D.ietf-dtn-bpsec"/> are to be used instead.
</t><t>
   Even when using TLS to secure the TCPCL session, the actual ciphersuite
   negotiated between the TLS peers MAY be insecure.
   TLS can be used to perform authentication without data confidentiality,
   for example.
   It is up to security policies within each TCPCL node to ensure that the 
   negotiated TLS ciphersuite meets transport security requirements.
   This is identical behavior to STARTTLS use in <xref target="RFC2595"/>.
</t><t>
   Another consideration for this protocol relates to denial-of-service
   attacks.  A node MAY send a large amount of data over a TCPCL
   session, requiring the receiving node to handle the data, attempt
   to stop the flood of data by sending a XFER_REFUSE message, or
   forcibly terminate the session.  This burden could cause denial of
   service on other, well-behaving sessions.  There is also nothing
   to prevent a malicious node from continually establishing sessions
   and repeatedly trying to send copious amounts of bundle data.  A
   listening node MAY take countermeasures such as ignoring TCP SYN
   messages, closing TCP connections as soon as they are established,
   waiting before sending the contact header, sending a SHUTDOWN message
   quickly or with a delay, etc.
</t>
</section>
<section anchor="sec-iana" title="IANA Considerations">
<t>
  In this section, registration procedures are as defined in <xref target="RFC5226"/>.
</t><t>
  Some of the registries below are created new for TCPCLv4 but share code 
  values with TCPCLv3. This was done to disambiguate the use of these values
  between TCPCLv3 and TCPCLv4 while preserving the semantics of some values.
</t>
<section anchor="sec-iana-port" title="Port Number">
<t>
  Port number 4556 has been previously assigned as the default port for the
  TCP convergence layer in <xref target="RFC7242"/>.
  This assignment is unchanged by protocol version 4.
  Each TCPCL node identifies its TCPCL protocol version in its initial 
  contact (see <xref target="sec-iana-protonum"/>), so there is no ambiguity about what protocol is being used.
</t>
<texttable>
  <ttcol>Parameter</ttcol><ttcol>Value</ttcol>
  <c>Service Name:</c><c>dtn-bundle</c>
  <c>Transport Protocol(s):</c><c>TCP</c>
  <c>Assignee:</c><c>Simon Perreault &lt;simon@per.reau.lt&gt;</c>
  <c>Contact:</c><c>Simon Perreault &lt;simon@per.reau.lt&gt;</c>
  <c>Description:</c><c>DTN Bundle TCP CL Protocol</c>
  <c>Reference:</c><c><xref target="RFC7242"/></c>
  <c>Port Number:</c><c>4556</c>
</texttable>
</section>
<section anchor="sec-iana-protonum" title="Protocol Versions">
<t>
   IANA has created, under the &quot;Bundle Protocol&quot; registry, a sub-
   registry titled &quot;Bundle Protocol TCP Convergence-Layer Version
   Numbers&quot; and initialized it with the following table.
   The registration procedure is RFC Required.
</t>
<texttable>
  <ttcol>Value</ttcol><ttcol>Description</ttcol><ttcol>Reference</ttcol>
  <c>0</c><c>Reserved</c><c><xref target="RFC7242"/></c>
  <c>1</c><c>Reserved</c><c><xref target="RFC7242"/></c>
  <c>2</c><c>Reserved</c><c><xref target="RFC7242"/></c>
  <c>3</c><c>TCPCL</c><c><xref target="RFC7242"/></c>
  <c>4</c><c>TCPCLbis</c><c>This specification.</c>
  <c>5-255</c><c>Unassigned</c>
</texttable>
</section>

<section anchor="sec-iana-header-extension-type" title="Header Extension Types">
<t>EDITOR NOTE: sub-registry to-be-created upon publication of this specification.</t>
<t>
   IANA will create, under the &quot;Bundle Protocol&quot; registry,
   a sub-registry titled 
   &quot;Bundle Protocol TCP Convergence-Layer Version 4 Header Extension Types&quot;
   and initialized it with the contents of <xref target="tab-iana-header-extension-type"/>.
   The registration procedure is RFC Required within the lower range 0x0001--0x3fff.
   Values in the range 0x8000--0xffff are reserved for use on private networks
   for functions not published to the IANA.
</t>
<texttable anchor="tab-iana-header-extension-type" title="Header Extension Type Codes">
  <ttcol>Code</ttcol><ttcol>Message Type</ttcol>
  <c>0x0000</c><c>Reserved</c>
  <c>0x0001--0x3fff</c><c>Unassigned</c>
  <c>0x8000--0xffff</c><c>Private/Experimental Use</c>
</texttable>
</section>

<section anchor="sec-iana-message-types" title="Message Types">
<t>EDITOR NOTE: sub-registry to-be-created upon publication of this specification.</t>
<t>
   IANA will create, under the &quot;Bundle Protocol&quot; registry,
   a sub-registry titled 
   &quot;Bundle Protocol TCP Convergence-Layer Version 4 Message Types&quot;
   and initialized it with the contents of <xref target="tab-iana-message-types"/>.
   The registration procedure is RFC Required.
</t>
<texttable anchor="tab-iana-message-types" title="Message Type Codes">
  <ttcol>Code</ttcol><ttcol>Message Type</ttcol>
  <c>0x00</c><c>Reserved</c>
  <c>0x01</c><c>XFER_SEGMENT</c>
  <c>0x02</c><c>XFER_ACK</c>
  <c>0x03</c><c>XFER_REFUSE</c>
  <c>0x04</c><c>KEEPALIVE</c>
  <c>0x05</c><c>SHUTDOWN</c>
  <c>0x06</c><c>XFER_INIT</c>
  <c>0x07</c><c>MSG_REJECT</c>
  <c>0x08--0xf</c><c>Unassigned</c>
</texttable>
</section>

<section anchor="sec-iana-refuse-codes" title="XFER_REFUSE Reason Codes">
<t>EDITOR NOTE: sub-registry to-be-created upon publication of this specification.</t>
<t>
   IANA will create, under the &quot;Bundle Protocol&quot; registry,
   a sub-registry titled 
   &quot;Bundle Protocol TCP Convergence-Layer Version 4 XFER_REFUSE Reason Codes&quot;
   and initialized it with the contents of <xref target="tab-iana-XFER_REFUSE-codes"/>.
   The registration procedure is RFC Required.
</t>
<texttable anchor="tab-iana-XFER_REFUSE-codes" title="XFER_REFUSE Reason Codes">
  <ttcol>Code</ttcol><ttcol>Refusal Reason</ttcol>
  <c>0x0</c><c>Unknown</c>
  <c>0x1</c><c>Completed</c>
  <c>0x2</c><c>No Resources</c>
  <c>0x3</c><c>Retransmit</c>
  <c>0x4--0x7</c><c>Unassigned</c>
  <c>0x8--0xf</c><c>Reserved for future usage</c>
</texttable>
</section>

<section anchor="sec-iana-shutdown-codes" title="SHUTDOWN Reason Codes">
<t>EDITOR NOTE: sub-registry to-be-created upon publication of this specification.</t>
<t>
   IANA will create, under the &quot;Bundle Protocol&quot; registry,
   a sub-registry titled 
   &quot;Bundle Protocol TCP Convergence-Layer Version 4 SHUTDOWN Reason Codes&quot;
   and initialized it with the contents of <xref target="tab-iana-SHUTDOWN-codes"/>.
   The registration procedure is RFC Required.
</t>
<texttable anchor="tab-iana-SHUTDOWN-codes" title="SHUTDOWN Reason Codes">
  <ttcol>Code</ttcol><ttcol>Shutdown Reason</ttcol>
  <c>0x00</c><c>Idle timeout</c>
  <c>0x01</c><c>Version mismatch</c>
  <c>0x02</c><c>Busy</c>
  <c>0x03</c><c>Contact Failure</c>
  <c>0x04</c><c>TLS failure</c>
  <c>0x05--0xFF</c><c>Unassigned</c>
</texttable>
</section>

<section anchor="sec-iana-reject-codes" title="MSG_REJECT Reason Codes">
<t>EDITOR NOTE: sub-registry to-be-created upon publication of this specification.</t>
<t>
   IANA will create, under the &quot;Bundle Protocol&quot; registry,
   a sub-registry titled 
   &quot;Bundle Protocol TCP Convergence-Layer Version 4 MSG_REJECT Reason Codes&quot;
   and initialized it with the contents of <xref target="tab-iana-reject-codes"/>.
   The registration procedure is RFC Required.
</t>
<texttable anchor="tab-iana-reject-codes" title="REJECT Reason Codes">
  <ttcol>Code</ttcol><ttcol>Rejection Reason</ttcol>
  <c>0x00</c><c>reserved</c>
  <c>0x01</c><c>Message Type Unknown</c>
  <c>0x02</c><c>Message Unsupported</c>
  <c>0x03</c><c>Message Unexpected</c>
  <c>0x04-0xFF</c><c>Unassigned</c>
</texttable>
</section>

</section>

<section anchor="sec-doc-ack" title="Acknowledgments">
<t>
    This memo is based on comments on implementation of 
    <xref target="RFC7242"/> provided from Scott Burleigh.
</t>
</section>
</middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.0793.xml"?>
      <?rfc include="reference.RFC.1122.xml"?>
      <?rfc include="reference.RFC.2119.xml"?>
      <?rfc include="reference.RFC.5050.xml"?>
      <?rfc include="reference.RFC.5226.xml"?>
      <?rfc include="reference.RFC.5246.xml"?>
      <?rfc include="reference.RFC.7525.xml"?>
      <?rfc include="reference.I-D.ietf-dtn-bpbis.xml"?>
    </references>
    <references title="Informative References">
      <?rfc include="reference.RFC.2595.xml"?>
      <?rfc include="reference.RFC.4838.xml"?>
      <?rfc include="reference.RFC.6257.xml"?>
      <?rfc include="reference.RFC.7242.xml"?>
      <?rfc include="reference.I-D.ietf-dtn-bpsec.xml"?>
    </references>
    
    <section title="Significant changes from RFC7242">
    <t>
    The areas in which changes from <xref target="RFC7242"/> have
    been made to existing headers and messages are:
    <list style="symbols">
      <t>Changed contact header content to limit number of negotiated options.</t>
      <t>Added contact option to negotiate maximum segment size (per each direction).</t>
      <t>Added contact header extension capability.</t>
      <t>Defined new IANA registries for message / type / reason codes to allow renaming some codes for clarity.</t>
      <t>Expanded Message Header to octet-aligned fields instead of bit-packing.</t>
      <t>Added a bundle transfer identification number to all bundle-related messages (XFER_INIT, XFER_SEGMENT, XFER_ACK, XFER_REFUSE).</t>
      <t>Use flags in XFER_ACK to mirror flags from XFER_SEGMENT.</t>
      <t>Removed all uses of SDNV fields and replaced with fixed-bit-length fields.</t>
    </list>
    </t>
    <t>
    The areas in which extensions from <xref target="RFC7242"/> have been
    made as new messages and codes are:
    <list style="symbols">
      <t>Added contact negotation failure SHUTDOWN reason code.</t>
      <t>Added MSG_REJECT message to indicate an unknown or unhandled message was received.</t>
      <t>Added TLS session security mechanism.</t>
      <t>Added TLS failure SHUTDOWN reason code.</t>
    </list>
    </t>
    </section>
  </back>
</rfc>
